<!DOCTYPE html>
<html>
<head>
<script src="https://bitcoincore.tech/apps/bitcoinjs-ui/lib/bitcoinjs-lib.js"></script>
<script src="https://bundle.run/varuint-bitcoin@1.1.2"></script>
<script src="https://bundle.run/bip39@3.0.4"></script>
<script src="https://bundle.run/bip32@2.0.6"></script>
<script src="https://bundle.run/buffer@6.0.3"></script>
<script src="https://bundle.run/noble-secp256k1@1.2.14"></script>
<script src="https://bundle.run/browserify-cipher@1.0.1"></script>
<script>
        function computeRawPrivkey( node ) {
                return bitcoinjs.ECPair.fromPrivateKey( node.privateKey, { network: bitcoinjs.networks.mainnet } );
        }
</script>
<script>
        function getPrivkeyHex( backupwords, path, index ) {
                var seed = bip39.mnemonicToSeedSync( backupwords );
                var node = bip32.fromSeed( seed );
                var path = "m/" + path + "/" + index;
                var root = node;
                var child = root.derivePath( path );
                return computeRawPrivkey( child );
        }
</script>
<script>
        function toHexString(byteArray) {
                return Array.from(byteArray, function(byte) {
                        return ('0' + (byte & 0xFF).toString(16)).slice(-2);
                }).join('');
        }
</script>
<script>
        var backupwords = bip39.generateMnemonic();
        var path = 0;
        var index = 1;
        var privKey = getPrivkeyHex( backupwords, path, index );
        privKey = privKey.__D.toString( 'hex' );
        var pubKey = nobleSecp256k1.getPublicKey( privKey, true );
        var pubKeyMinus2 = pubKey.substring( 2 );
</script>
<style>
        * {
                box-sizing: border-box;
                margin: 0px;
                padding: 0px;
        }
</style>
</head>
<body>
        <h1>This is a work in progress, it doesn't work yet</h1>
        <h1>Accept a coinflip</h1>
        <p>This coinflip site uses a remote coinflipping technique invented in 1981 by Michael Blum. Your opponent picked Heads or Tails and will shortly commit to it via a cryptographic hash on bitcoin's blockchain. Your role is to guess if your opponent picked Heads or Tails. Your opponent cannot change their choice after you guess because the blockchain is irreversible. If you guess correctly, you win the bet amount, otherwise your opponent wins. The rules of the game are enforced by a bitcoin smart contract. There are no third parties involved, only you and your opponent.</p>
        <p>Try clicking Heads or Tails below. You can see how your guess will appear on the blockchain (like your opponent's choice, your guess is also hashed). It is displayed as a 40 character string under the coin. Be aware that every time you play the game the hashes will be different because they are not literally a hash of the word Heads or the word Tails. The strings are hashes of random numbers that are either 16 bytes long (Heads) or 17 bytes long (Tails).</p>
        <p>When you are ready to commit to your guess, click Accept. Your opponent will be notified that you accepted their offer. You'll only need to pay money to commit your guess to the blockchain if your opponent agrees to play with you. You can also abort at any time except if your opponent wins (which is sort of an auto-abort situation anyway, one where you also can't get your money back).</p>
        <p>Your opponent</p>
        <p><input type="text" id="opponent" style="width: 100%; max-width: 350px; background-color: #cccccc;" disabled="true" /></p>
        <p>Amount of sats you can win</p>
        <p><input type="text" id="amount" style="width: 100%; max-width: 350px; background-color: #cccccc;" disabled="true" /></p>
        <p>When this offer expires</p>
        <p><input type="text" id="expiry" style="width: 100%; max-width: 350px; background-color: #cccccc;" disabled="true" /></p>
        <p>The hash of your opponent's choice of Heads or Tails</p>
        <p><input type="text" id="opp-hash" style="width: 100%; max-width: 350px; background-color: #cccccc;" disabled="true" /></p>
        <p>Bitcoin address where you'd like to receive your opponent's money (if you win)</p>
        <p><input type="text" id="address-one" placeholder="bc1a9baasdf0bo0hmb8fsad6tuij76asdf23abbsdf" style="width: 100%; max-width: 350px;" /></p>
        <p>Bitcoin address where you'd like to receive your deposit back (if you win -- note that this protocol uses two separate addresses for your deposit and your opponent's deposit and it also disperses funds in two separate transactions. Provide two different bitcoin addresses to avoid address reuse, or use the same one if you aren't concerned about privacy.)</p>
        <p><input type="text" id="address-two" placeholder="bc1b8fsad6tuij76asdf23abbsdfa9baasdf0bo0hm" style="width: 100%; max-width: 350px;" /></p>
        <p>Your guess</p>
        <p><button id="heads-btn">Heads</button></p>
        <p><button id="tails-btn">Tails</button></p>
        <p><button id="random-btn">Random</button></p>
        <p><button id="accept-btn">Accept</button></p>
        <img style="display: block;" id="obverse" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/Washington_Quarter_Silver_1944S_Obverse.png/477px-Washington_Quarter_Silver_1944S_Obverse.png" />
        <img style="display: none;" id="reverse" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3c/Washington_Quarter_Silver_1944S_Reverse.png/481px-Washington_Quarter_Silver_1944S_Reverse.png" />
        <input id="hash" type="text" disabled="true" style="width: 100%; max-width: 350px; background-color: #cccccc; font-family: monospace;" />
        <img style="display: block; cursor: pointer;" id="abort" src="https://brilliancebitcoin.github.io/coinflip/abort-sign.png" />
<script>
        window.onload = function() {
                if ( !sessionStorage[ "sixteenBytePreimage" ] || sessionStorage[ "sixteenBytePreimage" ] == "" ) {
                        var sixteenBytePreimage = get16BytePreimage();
                        sessionStorage[ "sixteenBytePreimage" ] = sixteenBytePreimage;
                }
                document.getElementById( "hash" ).value = bitcoinjs.crypto.hash160( buffer.Buffer.from( sessionStorage[ "sixteenBytePreimage" ], "hex" ) ).toString( "hex" );
        }
</script>
<script>
        document.getElementById( "heads-btn" ).addEventListener( "click", function() {
                document.getElementById( "obverse" ).style.display = "block";
                document.getElementById( "reverse" ).style.display = "none";
                if ( !sessionStorage[ "sixteenBytePreimage" ] || sessionStorage[ "sixteenBytePreimage" ] == "" ) {
                        var sixteenBytePreimage = get16BytePreimage();
                        sessionStorage[ "sixteenBytePreimage" ] = sixteenBytePreimage;
                }
                document.getElementById( "hash" ).value = bitcoinjs.crypto.hash160( buffer.Buffer.from( sessionStorage[ "sixteenBytePreimage" ], "hex" ) ).toString( "hex" );
        });
        document.getElementById( "tails-btn" ).addEventListener( "click", function() {
                document.getElementById( "obverse" ).style.display = "none";
                document.getElementById( "reverse" ).style.display = "block";
                if ( !sessionStorage[ "seventeenBytePreimage" ] || sessionStorage[ "seventeenBytePreimage" ] == "" ) {
                        var seventeenBytePreimage = get17BytePreimage();
                        sessionStorage[ "seventeenBytePreimage" ] = seventeenBytePreimage;
                }
                document.getElementById( "hash" ).value = bitcoinjs.crypto.hash160( buffer.Buffer.from( sessionStorage[ "seventeenBytePreimage" ], "hex" ) ).toString( "hex" );
        });
        document.getElementById( "random-btn" ).addEventListener( "click", function() {
                var rand = Math.floor( Math.random() * 2 );
                console.log( rand );
                if ( rand == 0 ) {
                        document.getElementById( "heads-btn" ).click();
                } else {
                        document.getElementById( "tails-btn" ).click();
                }
        });
        document.getElementById( "abort" ).addEventListener( "click", function() {
                var conf_message = "If you abort at this stage you won't lose any money and everything will reset. Please click ok if that is what you want or click cancel to continue playing the game.";
                if ( confirm( conf_message ) ) {
                        sessionStorage.clear();
                        localStorage.clear();
                        window.location.reload();
                }
        });
        document.getElementById( "accept-btn" ).addEventListener( "click", function() {
                acceptOrRejectCoinflipOffer( sessionStorage[ "offer-message" ], document.getElementById( "opponent" ).value );
        });
        function isJsonString(str) {
            try {
                JSON.parse(str);
            } catch (e) {
                return false;
            }
            return true;
        }
        function displayOffer( offer, id ) {
                if ( isJsonString( offer ) && JSON.parse( offer )[ "msgtype" ] && JSON.parse( offer )[ "hash" ] && JSON.parse( offer )[ "amount" ] && JSON.parse( offer )[ "pubkey" ] && JSON.parse( offer )[ "pubkeyForRevelationAddress" ] && JSON.parse( offer )[ "blocks_to_wait" ] && JSON.parse( offer )[ "blocks_to_wait_for_revelation_address" ] &&  JSON.parse( offer )[ "offer_expires" ] ) {
                        var expiry = JSON.parse( offer )[ "offer_expires" ];
                        var player1 = JSON.parse( offer )[ "pubkey" ];
                        var amount = JSON.parse( offer )[ "amount" ];
                        var opp_hash = JSON.parse( offer )[ "hash" ];
                        document.getElementById( "opponent" ).value = player1;
                        document.getElementById( "amount" ).value = amount;
                        document.getElementById( "expiry" ).value = new Date( expiry * 1000 ).toLocaleDateString() + " " + new Date( expiry * 1000 ).toLocaleTimeString();
                        document.getElementById( "opp-hash" ).value = opp_hash;
                }
        }
</script>
<script>
        var queryString = window.location.search;
        var urlParams = new URLSearchParams(queryString);
        function normalizeRelayURL(e){let[t,...r]=e.trim().split("?");return"http"===t.slice(0,4)&&(t="ws"+t.slice(4)),"ws"!==t.slice(0,2)&&(t="wss://"+t),t.length&&"/"===t[t.length-1]&&(t=t.slice(0,-1)),[t,...r].join("?")}
        var relay = "wss://nostr-relay.wlvs.space";
        relay = normalizeRelayURL( relay );
        var socket = new WebSocket( relay );
        var filter = {
                "#p": [
                        pubKeyMinus2
                ]
        };
        var subscription = [ "REQ", "get-self-references", filter ];
        subscription = JSON.stringify( subscription );
        sessionStorage[ "selfsubscription" ] = subscription;
        setTimeout( function() {socket.send( sessionStorage[ "selfsubscription" ] );}, 1000 );

        var filter = {
                "ids": [
                        urlParams.get( "id" )
                ]
        };
        var subscription2 = [ "REQ", "get-url-event", filter ];
        subscription2 = JSON.stringify( subscription2 );
        sessionStorage[ "urlevent" ] = subscription2;
        setTimeout( function() {socket.send( sessionStorage[ "urlevent" ] );}, 1000 );

        function subscribe( pubkey ) {
          var filter = {
                  "authors": [
                          pubkey
                  ]
          };
          var subscription = [ "REQ", "my-sub", filter ];
          subscription = JSON.stringify( subscription );
          sessionStorage.subscription = subscription;
          socket.send( sessionStorage.subscription );
        }

        socket.addEventListener( 'open', function( event ) {
                console.log( "connected to nostr relay " + relay );
        });

        // Listen for messages
        socket.addEventListener( 'message', function( event ) {
                var event = JSON.parse( event.data );
                if ( event[ 2 ].kind == 4 ) {
                        var i; for ( i=0; i<event[ 2 ].tags.length; i++ ) {
                                        if ( event[ 2 ].tags[ i ] && event[ 2 ].tags[ i ][ 1 ] ) {
                                                        var recipient = event[ 2 ].tags[ i ][ 1 ];
                                                        if ( recipient == pubKeyMinus2 ) {
                                                                        var decrypted_message = decrypt( privKey, event[ 2 ].pubkey, event[ 2 ].content );
                                                                        console.log( decrypted_message + " (sent privately by " + event[ 2 ].pubkey + ")" );
                                                                        decideMessageTypeAndNextSteps( decrypted_message, event[ 2 ].pubkey );
                                                        } else if ( event[ 2 ].pubkey == pubKeyMinus2 ) {
                                                                        console.log( decrypt( privKey, recipient, event[ 2 ].content ) + " (sent privately by " + event[ 2 ].pubkey + ")" );
                                                        }
                                        }
                        }
                } else if ( event[ 2 ].kind == 1 ) {
                        console.log( event[ 2 ].content + " (sent publicly by " + event[ 2 ].pubkey + ")" );
                } else if ( event[ 2 ].kind == 40 ) {
                        sessionStorage[ "offer-message" ] = event[ 2 ].content
                        displayOffer( event[ 2 ].content, event[ 2 ].id );
                }
        });
</script>
<script>
        function witnessStackToScriptWitness(witness) {
          let buffer2 = buffer.Buffer.allocUnsafe(0);
          function writeSlice(slice) {
            buffer2 = buffer.Buffer.concat([buffer2, buffer.Buffer.from(slice)]);
          }
          function writeVarInt(i) {
            const currentLen = buffer2.length;
            const varintLen = varuintBitcoin.encodingLength(i);
            buffer2 = buffer.Buffer.concat([buffer2, buffer.Buffer.allocUnsafe(varintLen)]);
            varuintBitcoin.encode(i, buffer2, currentLen);
          }
          function writeVarSlice(slice) {
            writeVarInt(slice.length);
            writeSlice(slice);
          }
          function writeVector(vector) {
            writeVarInt(vector.length);
            vector.forEach(writeVarSlice);
          }
          writeVector(witness);
          return buffer2;
        }
</script>
<script>
        function decideMessageTypeAndNextSteps( decrypted_message, sender ) {
                if ( decrypted_message.includes( '{' ) ) {
                        var json = JSON.parse( decrypted_message );
                        if ( json[ "msgtype" ] == "initiation" ) {
                                acceptOrRejectCoinflipOffer( decrypted_message, sender );
                        }
                        if ( json[ "msgtype" ] == "acceptance" ) {
                                acknowledgeOrIgnoreCoinflip( decrypted_message, sender );
                        }
                        if ( json[ "msgtype" ] == "ack" ) {
                                console.log( "Got an ack message. Here is the decrypted message followed by the sender's pubkey:" );
                                console.log( decrypted_message, sender );
                                decideWhetherToSendMoneyAsPlayer2( decrypted_message, sender );
                        }
                }
        }
        function get16BytePreimage() {
                var length = 32;
                var preimagestage1 = bitcoinjs.ECPair.makeRandom().__D.toString( "hex" );
                var preimagestage2 = preimagestage1.substring( 0, length );
                return preimagestage2;
        }
        function get17BytePreimage() {
                var length = 34;
                var preimagestage1 = bitcoinjs.ECPair.makeRandom().__D.toString( "hex" );
                var preimagestage2 = preimagestage1.substring( 0, length );
                return preimagestage2;
        }
        function getRandom16or17BytePreimage() {
                var length = 16 + Math.floor( Math.random() * 2 );
                if ( length == 16 ) {
                        length = 32;
                } else {
                        length = 34;
                }
                var preimagestage1 = bitcoinjs.ECPair.makeRandom().__D.toString( "hex" );
                var preimagestage2 = preimagestage1.substring( 0, length );
                return preimagestage2;
        }
        async function sweepMoneyFromRevelationAddressAsPlayer2( realjson ) {
                //player 2 runs this
                var revelation_txid = await addyLooper( realjson[ "revelation-address" ], "player2", "sweepFromRevelationAddress" );
                sessionStorage[ revelation_txid ] = "0";
                var blocks_to_wait_for_revelation_address = Number( realjson[ "blocks_to_wait_for_revelation_address" ] );
                var blocks_to_wait_for_revelation_address_as_player_2 = 1;
                //abort if the amount in the revelation address is lower than the agreed upon amount
                var amount_in_revelation_address = await getAmountOfTxThatSentMeMoney( realjson[ "revelation-address" ], revelation_txid );
                if ( Number( amount_in_revelation_address ) < Number( realjson[ "amount" ] ) ) {
                        alert( "Aborted because the other player sent the wrong amount of money" );
                } else {
                        confLooper( revelation_txid, blocks_to_wait_for_revelation_address_as_player_2 );
                        await waitForTheRightNumberOfConfs( revelation_txid, blocks_to_wait_for_revelation_address_as_player_2, "player2", realjson[ "revelation-address" ] );
                        var revelation_txindex = await getOutputNumberOfTxThatSentMeMoney( realjson[ "revelation-address" ], revelation_txid );
                        var original_quantity_of_sats_in_revelation_address = ( Number( realjson[ "amount" ] ) );
                        var new_quantity_of_sats_for_revealing_preimage = original_quantity_of_sats_in_revelation_address - 250;
                        var player2PrivkeyForRevelationAddress = realjson[ "player2PrivkeyForRevelationAddress" ];
                        var player2PubkeyForRevelationAddress = realjson[ "player2PubkeyForRevelationAddress" ];
                        var player1PubkeyForRevelationAddress = realjson[ "player1PubkeyForRevelationAddress" ];
                        var player2Preimage = realjson[ "player2Preimage" ];
                        var hash = realjson[ "player2Hash" ];
                        var useraddress_for_revelation_address = "tb1ql7w62elx9ucw4pj5lgw4l028hmuw80sndtntxt";
                        revealPreimage( player2Preimage, player1PubkeyForRevelationAddress, player2PrivkeyForRevelationAddress, blocks_to_wait_for_revelation_address, revelation_txid, revelation_txindex, original_quantity_of_sats_in_revelation_address, new_quantity_of_sats_for_revealing_preimage, useraddress_for_revelation_address );
                        console.log( "Almost done! You withdrew from the revelation address." );
                }
        }
        async function sweepMoneyFromRevelationAddressAsPlayer1( realjson ) {
                //player 1 runs this
                var revelation_txid = await addyLooper( realjson[ "revelation-address" ], "player1", "sweepFromRevelationAddress" );
                sessionStorage[ revelation_txid ] = "0";
                var blocks_to_wait_for_revelation_address = Number( realjson[ "blocks_to_wait_for_revelation_address" ] );
                confLooper( revelation_txid, blocks_to_wait_for_revelation_address );
                await waitForTheRightNumberOfConfs( revelation_txid, blocks_to_wait_for_revelation_address, "player2", realjson[ "revelation-address" ] );
                var revelation_txindex = await getOutputNumberOfTxThatSentMeMoney( realjson[ "revelation-address" ], revelation_txid );
                var original_quantity_of_sats_in_revelation_address = ( Number( realjson[ "amount" ] ) );
                var new_quantity_of_sats_for_withdrawing_after_timelock = original_quantity_of_sats_in_revelation_address - 250;
                var player1PrivkeyForRevelationAddress = realjson[ "player1PrivkeyForRevelationAddress" ];
                var player1PubkeyForRevelationAddress = realjson[ "player1PubkeyForRevelationAddress" ];
                var player2PubkeyForRevelationAddress = realjson[ "player2PubkeyForRevelationAddress" ];
                var hash = realjson[ "player2Hash" ];
                var useraddress_for_revelation_address = "tb1ql7w62elx9ucw4pj5lgw4l028hmuw80sndtntxt";
                withdrawFromRevelationAddressAfterTimelockAsPlayer1( revelation_txid, revelation_txindex, original_quantity_of_sats_in_revelation_address, new_quantity_of_sats_for_withdrawing_after_timelock, player1PrivkeyForRevelationAddress, player2PubkeyForRevelationAddress, Number( realjson[ "blocks_to_wait_for_revelation_address" ] ), hash, useraddress_for_revelation_address );
                console.log( "Aborted because player 2 took too long to reveal their preimage. If you waited any longer your money would be at risk." );
        }
        async function sweepMoneyFromCoinflipAddressAsPlayer2( realjson ) {
                //player 2 runs this
                var coinflip_txid = await addyLooper( realjson[ "coinflip-address" ], "player2", "sweepFromCoinflipAddress" );
                sessionStorage[ coinflip_txid ] = "0";
                confLooper( coinflip_txid, Number( realjson[ "blocks_to_wait" ] ) );
                var didILose = await waitForTheRightNumberOfConfs( coinflip_txid, Number( realjson[ "blocks_to_wait" ] ), "player2", realjson[ "coinflip-address" ] );
                //Stop running "waitfortherightnumberofconfs" if I see that the other party withdrew the money, i.e. if the address has a spent txo, and alert the player that they lost.
                if ( didILose == "You lost :(" ) {
                        alert( "Oh no! You lost :(" );
                } else {
                        var txindex = await getOutputNumberOfTxThatSentMeMoney( realjson[ "coinflip-address" ], coinflip_txid );
                        var original_quantity_of_sats = ( Number( realjson[ "amount" ] ) * 2 );
                        var new_quantity_of_sats = original_quantity_of_sats - 250;
                        var player2Privkey = realjson[ "player2Privkey" ];
                        var player2Pubkey = realjson[ "player2Pubkey" ];
                        var player1Pubkey = realjson[ "player1Pubkey" ];
                        var player2Hash = realjson[ "player2Hash" ];
                        var player1Hash = realjson[ "player1Hash" ];
                        var randomPreimage1 = getRandom16or17BytePreimage();
                        var randomPreimage2 = getRandom16or17BytePreimage();
                        var blocks_to_wait = realjson[ "blocks_to_wait" ];
                        var useraddress = "tb1ql7w62elx9ucw4pj5lgw4l028hmuw80sndtntxt";
                        player2WonCoinflip( coinflip_txid, txindex, original_quantity_of_sats, new_quantity_of_sats, player2Privkey, player2Pubkey, player1Pubkey, randomPreimage1, randomPreimage2, blocks_to_wait, useraddress, player1Hash, player2Hash );
                        console.log( "Done! You won the bet!" );
                }
        }
        async function decideWhetherToSendMoneyAsPlayer2( decrypted_message, player1 ) {
                //player 2 runs this
                var json = JSON.parse( decrypted_message );
                var realjson = JSON.parse( localStorage[ "coinflip-private-info" ] );
                console.log( "here are the contents of coinflip-private-info at the point when I am trying to write a script to sweep the revelation address:", realjson );
                if ( json[ "player2Hash" ] == realjson[ "player2Hash" ] ) {
                        console.log( "Send", ( Number( realjson[ "amount" ] ) * 2 ), "sats to this address:" );
                        console.log( realjson[ "coinflip-address" ] );
                        //run a sweep function that takes money out of the revelation address after however many confs you agreed on for the revelation address
                        sweepMoneyFromRevelationAddressAsPlayer2( realjson );
                        //run a sweep function that takes money out of the coinflup address after however many confs you agreed on for the coinflip address
                        sweepMoneyFromCoinflipAddressAsPlayer2( realjson );
                }
        }
        async function acknowledgeOrIgnoreCoinflip( decrypted_message, player2 ) {
                //player 1 runs this
                var json = JSON.parse( decrypted_message );
                var claimedPlayer1Hash = json[ "player1Hash" ];
                var claimedRevelationAddress = json[ "revelation-address" ];
                var realjson = JSON.parse( localStorage[ "coinflip-private-info" ] );
                var realPlayer1Hash = realjson[ "player1Hash" ];
                if ( claimedPlayer1Hash == realPlayer1Hash ) {
                        var player2Hash = json[ "player2Hash" ];
                        var player2Pubkey = json[ "player2Pubkey" ];
                        var player1Hash = realPlayer1Hash;
                        var player1Pubkey = realjson[ "player1Pubkey" ];
                        var player1PubkeyForRevelationAddress = realjson[ "player1PubkeyForRevelationAddress" ];
                        var player2PubkeyForRevelationAddress = json[ "player2PubkeyForRevelationAddress" ];
                        var blocks_to_wait = Number( realjson[ "blocks_to_wait" ] );
                        var blocks_to_wait_for_revelation_address = Number( realjson[ "blocks_to_wait_for_revelation_address" ] );
                        console.log( "ok time to pay attention" );
                        console.log( player2Hash, player1Pubkey, player2Pubkey, blocks_to_wait );
                        var witnessscript = prepCoinflip( player1Hash, player2Hash, player1Pubkey, player2Pubkey, blocks_to_wait );
                        console.log( "witness script:", witnessscript );
                        var p2wsh = bitcoinjs.payments.p2wsh({redeem: {output: witnessscript, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
                        var witness_script_for_revelation_address = reveal_and_redeem( player2Hash, player1PubkeyForRevelationAddress, player2PubkeyForRevelationAddress, Number( blocks_to_wait_for_revelation_address ) );
                        console.log( "witness script for revelation address:", witness_script_for_revelation_address );
                        var p2wsh_for_revelation_address = bitcoinjs.payments.p2wsh({redeem: {output: witness_script_for_revelation_address, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
                        var revelation_address = p2wsh_for_revelation_address.address;
                        if ( p2wsh.address == json[ "coinflip-address" ] && revelation_address == claimedRevelationAddress ) {
                                //update the private info
                                var coinflip_private_info = JSON.parse( localStorage[ "coinflip-private-info" ] );
                                coinflip_private_info[ "coinflip-address" ] = p2wsh.address;
                                coinflip_private_info[ "revelation-address" ] = revelation_address;
                                coinflip_private_info[ "player1Ack" ] = "ack";
                                coinflip_private_info[ "player2Hash" ] = player2Hash;
                                coinflip_private_info[ "player2Pubkey" ] = player2Pubkey;
                                coinflip_private_info[ "player2PubkeyForRevelationAddress" ] = player2PubkeyForRevelationAddress;
                                localStorage[ "coinflip-private-info" ] = JSON.stringify( coinflip_private_info );
                                //send an ack
                                var message = {}
                                message[ "msgtype" ] = "ack";
                                message[ "player1Hash" ] = player1Hash;
                                message[ "player2Hash" ] = player2Hash;
                                message = JSON.stringify( message );
                                makePrivateNote( message, player2 );
                                //listen for a transaction into the coinflip address and if it arrives with an amount 2x the bet amount, await 1 confirmation
                                var coinflip_txid = await addyLooper( p2wsh.address, "player1", "depositIntoRevelationAddress" );
                                //Player 1 aborts (by not depositing money into the revelation address) if the coinflip address does not have money in it within 3 blocks after the game starts. The logic for this is in addyLooper.
                                sessionStorage[ coinflip_txid ] = "0";
                                var actual_amount_in_coinflip_address = await getAmountOfTxThatSentMeMoney( p2wsh.address, coinflip_txid );
                                if ( Number( actual_amount_in_coinflip_address ) >= ( Number( realjson[ "amount" ] ) * 2 ) ) {
                                        confLooper( coinflip_txid, 1 );
                                        var confs = await waitForTheRightNumberOfConfs( coinflip_txid, 1, "player1", coinflip_private_info[ "coinflip-address" ] );
                                        console.log( "Send", ( Number( coinflip_private_info[ "amount" ] ) ), "sats to this address:" );
                                        //The following sweep function sweeps money out of the revelation address if necessary after awaiting however many confs were agreed upon for the revelation address.
                                        //Remember that the revelation address should expire 4 blocks before the coinflip address, but since I assume it is possible that the player 2 has two blocks that player 1 doesn't know about, I also must assume it is possible for the revelation address to expire only 2 blocks before the coinflip address. Still, that shouldn't change anything if it happens, player 1 should still just abort and withdraw their money at that point, which should be plenty of time before player 2 can do anything nefarious.
                                        //TODO_TEST: Test what happens if player 2 decides to make a race condition here by broadcasting their preimage-based withdrawal at the same time as player 1's timelock-based withdrawal. What ought to happen is that player 1 should still get player 2's preimage and use it to try to withdraw from the coinflip address if they won. Status: I tried to create a race condition after player 1 broadcasted a transaction withdrawing their money but I got an error that said my transaction needs at least one input. I kind of expected it to say you can't spend an input that's already spent, and I also wondered if it might say I need to bump the fee higher to do rbf (which I don't think was even enabled), but the error I got is a little different from both of those (though it is kind of similar to the first one). I decoded the transaction on blockcypher and it seemed to have an input to me. So I'm not sure what to think of that but now I want to test what happens if player 2 broadcasts first.
                                        sweepMoneyFromRevelationAddressAsPlayer1( coinflip_private_info );
                                        console.log( coinflip_private_info[ "revelation-address" ] );
                                        var player2Preimage = await preimageLooper( coinflip_private_info[ "revelation-address" ], coinflip_private_info[ "player2Hash" ] );
                                        var player2PreimageLength = player2Preimage.length / 2;
                                        var player1Preimage = coinflip_private_info[ "player1Preimage" ];
                                        var player1PreimageLength = player1Preimage.length / 2;
                                        if ( player2PreimageLength != player1PreimageLength ) {
                                                var txid = coinflip_txid;
                                                var txindex = await getOutputNumberOfTxThatSentMeMoney( p2wsh.address, coinflip_txid );
                                                var original_quantity_of_sats = Number( actual_amount_in_coinflip_address );
                                                var new_quantity_of_sats = actual_amount_in_coinflip_address - 250;
                                                var player1Privkey = coinflip_private_info[ "player1Privkey" ];
                                                var player1Pubkey = coinflip_private_info[ "player1Pubkey" ];
                                                var player2Pubkey = coinflip_private_info[ "player2Pubkey" ];
                                                var useraddress = "tb1ql7w62elx9ucw4pj5lgw4l028hmuw80sndtntxt";
                                                player1WonCoinflip( txid, txindex, original_quantity_of_sats, new_quantity_of_sats, player1Privkey, player1Pubkey, player2Pubkey, player1Preimage, player2Preimage, blocks_to_wait, useraddress );
                                                console.log( "Done! You won the bet!" );
                                        } else {
                                                console.log( "I lost. :(" );
                                        }
                                }
                        }
                }
        }
        function acceptOrRejectCoinflipOffer( decrypted_message, player1 ) {
                //player 2 runs this
                var json = JSON.parse( decrypted_message );
                //TODO: ensure each player can modify what wait times they'll accept for the coinflip address and the revelation address
                var blocks_to_wait = Number( json[ "blocks_to_wait" ] );
                var blocks_to_wait_for_revelation_address = Number( json[ "blocks_to_wait_for_revelation_address" ] );
                var amount = Number( json[ "amount" ] );
                //Note: The minimum wait time for the coinflip address that player 1 will accept is 8 blocks, see the note under the function "acceptOrRejectCoinflipOffer" for reasons why. Player 2 sets a maximum of 1 more than that so that he doesn't have to wait forever.
                var maximum_blocks_to_wait = 9;
                if ( blocks_to_wait > maximum_blocks_to_wait ) {
                        return;
                }
                //Note: 4 blocks is the minimum expiry player 2 should accept for the revelation address. As long as it is 4 or more, player 2 doesn't need to worry if player 1 deposits money into the revelation address even with only 2 or 1 blocks left before the coinflip address expires. The worst case scenario that I think is worth considering is that player 1 knows about 2 blocks that player 2 doesn't know about. That is in a category that I consider unlikely-yes-but-still-too-possible if blocks are clearing quickly that day. If therefore player 1 only had to wait 3 blocks before withdrawing their money from the revelation address, and if player 1 knew about 2 blocks that player 2 didn't know about, player 1 could profit if player 2 revealed their preimage because player 1 could try to sweep money out of the revelation address *and* get player 2's preimage. (This would be possible under a 3 block waiting period because, if player 1 knew about 2 blocks that player 2 didn't know about, and player 2 disclosed their preimage, then player 2's transaction sweeping funds from the revelation address and player 1's transaction sweeping money from the revelation address would both be valid as of the next block, creating a race condition -- except regardless of the outcome of the race condition, player 1 would know player 2's preimage.) That could cause player 2 to reveal their preimage without gaining anything, which isn't supposed to happen. So player 2 needs to make sure player 1 waits at least 4 blocks before withdrawing their money from the revelation address, because I consider it so-unlikely-as-to-be-basically-impossible that player 1 knows about 3 blocks that player 2 doesn't know about. Therefore as long as player 1 has to wait 4 blocks, if player 1 deposits money into the revelation address when there are only 2 blocks before the coinflip address expires, player 2 should be happy to reveal his preimage, because even if the other party knows about 2 blocks that he doesn't know about yet, that only means the coinflip address actually expired without player 2 knowing about it for a few seconds, and in that case, he can be sure he'll learn about it before player 1 can withdraw their money from the revelation address, which means that player 2 can try to withdraw from the coinflip address *right now,* and they can *definitely* withdraw from the revelation address (player 1 still has to wait at least 2 blocks, even if he knows about 2 that player 2 doesn't know about), so player 2 can definitely sweep money out of the revelation address *and* (maybe) out of the revelation address (that part would just be a race, if player 1 won).
                var acceptable_blocks_to_wait_for_revelation_address = 4;
                if ( blocks_to_wait_for_revelation_address < acceptable_blocks_to_wait_for_revelation_address ) {
                        return;
                }
                if ( amount < Number( sessionStorage[ "minimum" ] ) || amount > Number( sessionStorage[ "maximum" ] ) ) {
                        return;
                }
                console.log( json );
                var player1Hash = json[ "hash" ];
                var player1Pubkey = json[ "pubkey" ];
                var player1PubkeyForRevelationAddress = json[ "pubkeyForRevelationAddress" ];
                var player2Preimage = getRandom16or17BytePreimage();
                console.log( "this is player two's preimage:", player2Preimage );
                console.log( "this is its length:", player2Preimage.length / 2 );
                var player2Hash = bitcoinjs.crypto.hash160( buffer.Buffer.from( player2Preimage, "hex" ) ).toString( "hex" );
                var player2Keypair = bitcoinjs.ECPair.makeRandom();
                var player2Privkey = player2Keypair.__D.toString( "hex" );
                var player2Pubkey = player2Keypair.publicKey.toString( "hex" );
                var player2KeypairForRevelationAddress = bitcoinjs.ECPair.makeRandom();
                var player2PrivkeyForRevelationAddress = player2Keypair.__D.toString( "hex" );
                var player2PubkeyForRevelationAddress = player2Keypair.publicKey.toString( "hex" );
                var witnessscript = prepCoinflip( player1Hash, player2Hash, player1Pubkey, player2Pubkey, blocks_to_wait );
                console.log( "witness script:", witnessscript );
                var p2wsh = bitcoinjs.payments.p2wsh({redeem: {output: witnessscript, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
                console.log( p2wsh.address );
                var witness_script_for_revelation_address = reveal_and_redeem( player2Hash, player1PubkeyForRevelationAddress, player2PubkeyForRevelationAddress, Number( blocks_to_wait_for_revelation_address ) );
                console.log( "witness script for relelation address:", witness_script_for_revelation_address );
                var p2wsh_for_revelation_address = bitcoinjs.payments.p2wsh({redeem: {output: witness_script_for_revelation_address, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
                var revelation_address = p2wsh_for_revelation_address.address;
                var coinflipPrivateInfo = {}
                coinflipPrivateInfo[ "player1" ] = player1;
                coinflipPrivateInfo[ "blocks_to_wait" ] = blocks_to_wait;
                coinflipPrivateInfo[ "blocks_to_wait_for_revelation_address" ] = blocks_to_wait_for_revelation_address;
                coinflipPrivateInfo[ "amount" ] = amount;
                coinflipPrivateInfo[ "player1Hash" ] = player1Hash;
                coinflipPrivateInfo[ "player1Pubkey" ] = player1Pubkey;
                coinflipPrivateInfo[ "player1PubkeyForRevelationAddress" ] = player1PubkeyForRevelationAddress;
                coinflipPrivateInfo[ "player2Preimage" ] = player2Preimage;
                coinflipPrivateInfo[ "player2Hash" ] = player2Hash;
                coinflipPrivateInfo[ "player2Privkey" ] = player2Privkey;
                coinflipPrivateInfo[ "player2Pubkey" ] = player2Pubkey;
                coinflipPrivateInfo[ "player2PrivkeyForRevelationAddress" ] = player2PrivkeyForRevelationAddress;
                coinflipPrivateInfo[ "player2PubkeyForRevelationAddress" ] = player2PubkeyForRevelationAddress;
                coinflipPrivateInfo[ "coinflip-address" ] = p2wsh.address;
                coinflipPrivateInfo[ "player1Ack" ] = "";
                coinflipPrivateInfo[ "revelation-address" ] = revelation_address;
                localStorage[ "coinflip-private-info" ] = JSON.stringify( coinflipPrivateInfo );
                console.log( coinflipPrivateInfo );
                var message = {}
                message[ "msgtype" ] = "acceptance";
                message[ "player1Hash" ] = player1Hash;
                message[ "player2Hash" ] = player2Hash;
                message[ "player2Pubkey" ] = player2Pubkey;
                message[ "player2PubkeyForRevelationAddress" ] = player2PubkeyForRevelationAddress;
                message[ "coinflip-address" ] = p2wsh.address;
                message[ "revelation-address" ] = revelation_address;
                message = JSON.stringify( message );
                makePrivateNote( message, player1 );
        }
        function startACoinflip( player2, amount ) {
                //player 1 runs this
                var player1Preimage = getRandom16or17BytePreimage();
                console.log( "this is player one's preimage:", player1Preimage );
                console.log( "this is its length:", player1Preimage.length / 2 );
                var player1Hash = bitcoinjs.crypto.hash160( buffer.Buffer.from( player1Preimage, "hex" ) ).toString( "hex" );
                var player1Keypair = bitcoinjs.ECPair.makeRandom();
                var player1Privkey = player1Keypair.__D.toString( "hex" );
                var player1Pubkey = player1Keypair.publicKey.toString( "hex" );
                var player1KeypairForRevelationAddress = bitcoinjs.ECPair.makeRandom();
                var player1PrivkeyForRevelationAddress = player1KeypairForRevelationAddress.__D.toString( "hex" );
                var player1PubkeyForRevelationAddress = player1KeypairForRevelationAddress.publicKey.toString( "hex" );
                //Note: The minimum wait time for the revelation address that player 2 will accept is 4 blocks, see the note under the function "acceptOrRejectCoinflipOffer" for reasons why. A consequence of this is that the minimum wait time for the coinflip address should be 8 blocks. That is for several reasons, one of which is, Player 1 doesn't know if player 2 has 2 blocks that player 1 doesn't know about. Therefore Player 1 should not deposit money into the revelation address if the coinflip address is within 6 blocks of expiring, because otherwise player 2 could delay revealing their preimage until the revelation address's 4 blocks expire, which would be after (or at the same time as) they can withdraw money from the coinflip address. That would allow them to get Alice's money even if Alice won the coinflip, without giving Alice any recourse. Which means the minimum number of confs that player 1 should accept for the coinflip address is 8 if the wait time for the revelation address is 4 blocks. (Generalizing, player 1 should have a rule that the minimum wait time for the coinflip address be 4 more than the wait time for the revelation address, that way there is a next-to-impossible chance that player 2 can withdraw their money before player 1 can determine if they won the game. Also notable is that if the wait time for the coinflip address was only 3 more than the wait time for the revelation address, and if player 2 had 2 blocks that player 1 did not know about, player 2's withdrawal transaction would be valid at the same time as player 1's withdrawal transaction, creating a race condition. So player 1's minimum acceptable wait time for the coinflip address should be 4 more than the wait time of the revelation address.)
                var blocks_to_wait = "8";
                var blocks_to_wait_for_revelation_address = "4";
                //TODO: ensure each player can modify what wait times they'll accept for the coinflip address and the revelation address
                var message = {}
                message[ "msgtype" ] = "initiation";
                message[ "hash" ] = player1Hash;
                message[ "amount" ] = Number( amount );
                message[ "pubkey" ] = player1Pubkey;
                message[ "pubkeyForRevelationAddress" ] = player1PubkeyForRevelationAddress;
                message[ "blocks_to_wait" ] = blocks_to_wait;
                message[ "blocks_to_wait_for_revelation_address" ] = blocks_to_wait_for_revelation_address;
                message = JSON.stringify( message );
                var coinflipPrivateInfo = {}
                coinflipPrivateInfo[ "player2" ] = player2;
                coinflipPrivateInfo[ "blocks_to_wait" ] = blocks_to_wait;
                coinflipPrivateInfo[ "blocks_to_wait_for_revelation_address" ] = blocks_to_wait_for_revelation_address;
                coinflipPrivateInfo[ "amount" ] = Number( amount );
                coinflipPrivateInfo[ "player1Preimage" ] = player1Preimage;
                coinflipPrivateInfo[ "player1Hash" ] = player1Hash;
                coinflipPrivateInfo[ "player1Privkey" ] = player1Privkey;
                coinflipPrivateInfo[ "player1Pubkey" ] = player1Pubkey;
                coinflipPrivateInfo[ "player1PrivkeyForRevelationAddress" ] = player1PrivkeyForRevelationAddress;
                coinflipPrivateInfo[ "player1PubkeyForRevelationAddress" ] = player1PubkeyForRevelationAddress;
                coinflipPrivateInfo[ "player2Hash" ] = "";
                coinflipPrivateInfo[ "player2Pubkey" ] = "";
                coinflipPrivateInfo[ "player2PubkeyForRevelationAddress" ] = "";
                coinflipPrivateInfo[ "coinflip-address" ] = "";
                coinflipPrivateInfo[ "player1Ack" ] = "";
                coinflipPrivateInfo[ "revelation-address" ] = "";
                localStorage[ "coinflip-private-info" ] = JSON.stringify( coinflipPrivateInfo );
                console.log( coinflipPrivateInfo );
                makePrivateNote( message, player2 );
        }
        function createOffer( amount, preimage ) {
                //player 1 runs this
                var player1Preimage = preimage;
                console.log( "this is player one's preimage:", player1Preimage );
                console.log( "this is its length:", player1Preimage.length / 2 );
                var player1Hash = bitcoinjs.crypto.hash160( buffer.Buffer.from( player1Preimage, "hex" ) ).toString( "hex" );
                var player1Keypair = bitcoinjs.ECPair.makeRandom();
                var player1Privkey = player1Keypair.__D.toString( "hex" );
                var player1Pubkey = player1Keypair.publicKey.toString( "hex" );
                var player1KeypairForRevelationAddress = bitcoinjs.ECPair.makeRandom();
                var player1PrivkeyForRevelationAddress = player1KeypairForRevelationAddress.__D.toString( "hex" );
                var player1PubkeyForRevelationAddress = player1KeypairForRevelationAddress.publicKey.toString( "hex" );
                var blocks_to_wait = "8";
                var blocks_to_wait_for_revelation_address = "4";
                //TODO: ensure each player can modify what wait times they'll accept for the coinflip address and the revelation address
                var message = {}
                message[ "msgtype" ] = "offer";
                message[ "hash" ] = player1Hash;
                message[ "amount" ] = Number( amount );
                message[ "pubkey" ] = player1Pubkey;
                message[ "pubkeyForRevelationAddress" ] = player1PubkeyForRevelationAddress;
                message[ "blocks_to_wait" ] = blocks_to_wait;
                message[ "blocks_to_wait_for_revelation_address" ] = blocks_to_wait_for_revelation_address;
                message[ "offer_expires" ] = Math.floor( Date.now() / 1000 ) + 600;
                message = JSON.stringify( message );
                var coinflipPrivateInfo = {}
                coinflipPrivateInfo[ "player2" ] = "";
                coinflipPrivateInfo[ "blocks_to_wait" ] = blocks_to_wait;
                coinflipPrivateInfo[ "blocks_to_wait_for_revelation_address" ] = blocks_to_wait_for_revelation_address;
                coinflipPrivateInfo[ "amount" ] = Number( amount );
                coinflipPrivateInfo[ "player1Preimage" ] = player1Preimage;
                coinflipPrivateInfo[ "player1Hash" ] = player1Hash;
                coinflipPrivateInfo[ "player1Privkey" ] = player1Privkey;
                coinflipPrivateInfo[ "player1Pubkey" ] = player1Pubkey;
                coinflipPrivateInfo[ "player1PrivkeyForRevelationAddress" ] = player1PrivkeyForRevelationAddress;
                coinflipPrivateInfo[ "player1PubkeyForRevelationAddress" ] = player1PubkeyForRevelationAddress;
                coinflipPrivateInfo[ "player2Hash" ] = "";
                coinflipPrivateInfo[ "player2Pubkey" ] = "";
                coinflipPrivateInfo[ "player2PubkeyForRevelationAddress" ] = "";
                coinflipPrivateInfo[ "coinflip-address" ] = "";
                coinflipPrivateInfo[ "player1Ack" ] = "";
                coinflipPrivateInfo[ "revelation-address" ] = "";
                localStorage[ "coinflip-private-info" ] = JSON.stringify( coinflipPrivateInfo );
                console.log( coinflipPrivateInfo );
                putOfferOnNostr( message );
        }
</script>
<script>
        async function waitForTheRightNumberOfConfs( txid, num, player, address ) {
                if ( player == "player2" ) {
                        var tx_id = await addressOnceSentMoney( address );
                        if ( tx_id ) { 
                                return "You lost :(";
                        }
                }
                console.log( "loading confs for txid", txid + "..."  );
                num = Number( num );
                return new Promise( function( resolve, reject ) {
                        var confs = Number( sessionStorage[ txid ] );
                        console.log( "how many confs the txid has:", confs );
                        console.log( "how many confs it needs:", num );
                        console.log( "the first number is smaller than the second number:", confs < num );
                        if ( confs < num ) {
                                console.log( "since the first number was smaller than the second number I will rerun the function that waits for the right number of confs" );
                                setTimeout( async function() {
                                        var confs = await waitForTheRightNumberOfConfs( txid, num, player, address );
                                        resolve( confs );
                                }, 5000 );
                        } else {
                                resolve( confs );
                        }
                });
        }
        async function addyLooper( address, player, stage ) {
                if ( player == "player1" && stage == "depositIntoRevelationAddress" ) {
                        var current_blockheight = await getBlockheight();
                        console.log( "current_blockheight:", current_blockheight );
                        if ( !sessionStorage[ "block_when_game_started" ] || sessionStorage[ "block_when_game_started" ] == "" ) {
                                var block_when_game_started = current_blockheight;
                                sessionStorage[ "block_when_game_started" ] = block_when_game_started;
                        }
                        console.log( "block_when_game_started:", Number( sessionStorage[ "block_when_game_started" ] ) );
                        if ( Number( current_blockheight ) >= Number( sessionStorage[ "block_when_game_started" ] ) + 3 ) {
                                sessionStorage[ "status" ] = "aborted";
                                alert( "Aborted because Player 2 took too long to deposit money." );
                        }
                }
                console.log( "loading txid for address", address + "..." );
                return new Promise( async function( resolve, reject ) {
                        var txid = await getIdOfTxThatSentMeMoney( address );
                        if ( txid == "none" ) {
                                if ( sessionStorage[ "status" ] == "aborted" ) {
                                        resolve( "none" );
                                } else {
                                        setTimeout( async function() {
                                                var txid = await addyLooper( address, player, stage );
                                                resolve( txid );
                                        }, 5000 );
                                }
                        } else {
                                resolve( txid );
                        }
                });
        }
        async function addyOutLooper( address ) {
                console.log( "loading spending txid for address", address + "..." );
                return new Promise( async function( resolve, reject ) {
                        var txid = await addressOnceSentMoney( address );
                        if ( !txid ) {
                                setTimeout( async function() {
                                        var txid = await addyOutLooper( address );
                                        resolve( txid );
                                }, 5000 );
                        } else {
                                resolve( txid );
                        }
                });
        }
        async function confLooper( txid, blocks_to_wait ) {
                blocks_to_wait = Number( blocks_to_wait );
                var confs = await howManyConfs( txid );
                confs = Number( confs );
                console.log( "waiting for confs involving this tx:", txid, "(I have to wait", blocks_to_wait, "blocks)" );
                sessionStorage[ txid ] = confs;
                if ( confs < blocks_to_wait ) {
                        setTimeout( function() {confLooper( txid, blocks_to_wait );}, 5000 );
                }
        }
        async function preimageLooper( address, hash ) {
                return new Promise( async function( resolve, reject ) {
                        var preimage = await getSweepablePreimageFromAllPossibilities( address, hash );
                        if ( !preimage || preimage == "" ) {
                                setTimeout( async function() {
                                        console.log( "loading preimage for hash", hash + "..." );
                                        var preimage = await preimageLooper( address, hash );
                                        resolve( preimage );
                                }, 15000 );
                        } else {
                                resolve( preimage );
                        }
                });
        }
        async function howManyConfs( txid ) {
            var blockheight = await getBlockheight();
            return new Promise( function( resolve, reject ) {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                    if ( this.readyState == 4 && this.status == 200 ) {
                        var json = JSON.parse( xhttp.responseText );
                        if ( json[ "status" ][ "confirmed" ] ) {
                            resolve( ( Number( blockheight ) - Number( json[ "status" ][ "block_height" ] ) ) + 1 );
                        } else {
                            resolve( "0".toString() );
                        }
                    }
                };
                xhttp.open( "GET", "https://blockstream.info/testnet/api/tx/" + txid, true );
                xhttp.send();
            });
        }
        async function getIdOfTxThatSentMeMoney( address ) {
            return new Promise( function( resolve, reject ) {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                    if ( this.readyState == 4 && this.status == 200 ) {
                        var json = JSON.parse( xhttp.responseText );
                        json.reverse();
                        var counter = 0;
                        json.forEach( function( tx ) {
                            tx[ "vout" ].forEach( function( vout ) {
                                if ( counter == 0 ) {
                                    if ( "scriptpubkey_address" in vout && vout[ "scriptpubkey_address" ] == address ) {
                                          resolve( tx[ "txid" ] );
                                          counter = counter + 1;
                                    }
                                }
                            });
                        });
                        resolve( "none" );
                    }
                };
                xhttp.open( "GET", "https://blockstream.info/testnet/api/address/" + address + "/txs", true );
                xhttp.send();
            });
        }
        function getOutputNumberOfTxThatSentMeMoney( address, txid ) {
            return new Promise( function( resolve, reject ) {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                    if ( this.readyState == 4 && this.status == 200 ) {
                        var json = JSON.parse( xhttp.responseText );
                        json.reverse();
                        var counter = 0;
                        json.forEach( function( tx ) {
                            tx[ "vout" ].forEach( function( vout, index ) {
                                if ( counter == 0 ) {
                                    if ( "scriptpubkey_address" in vout && vout[ "scriptpubkey_address" ] == address ) {
                                          resolve( index );
                                          counter = counter + 1;
                                    }
                                }
                            });
                        });
                    }
                };
                xhttp.open( "GET", "https://blockstream.info/testnet/api/address/" + address + "/txs", true );
                xhttp.send();
            });
        }
        function getAmountOfTxThatSentMeMoney( address, txid ) {
            return new Promise( function( resolve, reject ) {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                    if ( this.readyState == 4 && this.status == 200 ) {
                        var json = JSON.parse( xhttp.responseText );
                        json.reverse();
                        var counter = 0;
                        json.forEach( function( tx ) {
                            tx[ "vout" ].forEach( function( vout ) {
                                if ( counter == 0 ) {
                                    if ( "scriptpubkey_address" in vout && vout[ "scriptpubkey_address" ] == address ) {
                                          resolve( vout[ "value" ] );
                                          counter = counter + 1;
                                    }
                                }
                            });
                        });
                    }
                };
                xhttp.open( "GET", "https://blockstream.info/testnet/api/address/" + address + "/txs", true );
                xhttp.send();
            });
        }
</script>
<script>
        function prepCoinflip( player1Hash, player2Hash, player1Pubkey, player2Pubkey, blocks_to_wait ) {
            return bitcoinjs.script.fromASM(
                `
                    OP_TOALTSTACK
                    OP_DUP
                    OP_HASH160
                    ${ player1Hash }
                    OP_EQUAL
                    OP_NOTIF
                        OP_FALSE
                        OP_NIP
                    OP_ENDIF
                    OP_SIZE
                    ${ bitcoinjs.script.number.encode( 16 ).toString( 'hex' ) }
                    OP_EQUAL
                    OP_SWAP
                    OP_DROP
                    OP_FROMALTSTACK
                    OP_DUP
                    OP_HASH160
                    ${ player2Hash }
                    OP_EQUAL
                    OP_NOTIF
                        OP_FALSE
                        OP_NIP
                    OP_ENDIF
                    OP_SIZE
                    ${ bitcoinjs.script.number.encode( 16 ).toString( 'hex' ) }
                    OP_EQUAL
                    OP_SWAP
                    OP_DROP
                    OP_NUMNOTEQUAL
                    OP_IF
                        ${ player1Pubkey }
                    OP_ELSE
                        ${ bitcoinjs.script.number.encode( blocks_to_wait ).toString( 'hex' ) }
                        OP_CHECKSEQUENCEVERIFY
                        OP_DROP
                        ${ player2Pubkey }
                    OP_ENDIF
                    OP_CHECKSIG
                `
                .trim()
                .replace(/\s+/g, ' '),
            );
        }
        function reveal_and_redeem( player2Hash, player1Pubkey, player2Pubkey, blocks_to_wait ) {
            return bitcoinjs.script.fromASM(
                `
                    OP_SIZE
                    ${ bitcoinjs.script.number.encode( 16 ).toString( 'hex' ) }
                    ${ bitcoinjs.script.number.encode( 18 ).toString( 'hex' ) }
                    OP_WITHIN
                    OP_IF
                        OP_HASH160
                        ${ player2Hash }
                        OP_EQUALVERIFY
                        ${ player2Pubkey }
                    OP_ELSE
                       ${ bitcoinjs.script.number.encode( blocks_to_wait ).toString( 'hex' ) }
                       OP_CHECKSEQUENCEVERIFY
                       OP_DROP
                       ${ player1Pubkey }
                    OP_ENDIF
                    OP_CHECKSIG
                `
                .trim()
                .replace(/\s+/g, ' '),
            );
        }
        function player1WonCoinflip( txid, txindex, original_quantity_of_sats, new_quantity_of_sats, player1Privkey, player1Pubkey, player2Pubkey, player1Preimage, player2Preimage, blocks_to_wait, useraddress ) {
            var player1Hash = bitcoinjs.crypto.hash160( buffer.Buffer.from( player1Preimage, "hex" ) ).toString( 'hex' );
            var player2Hash = bitcoinjs.crypto.hash160( buffer.Buffer.from( player2Preimage, "hex" ) ).toString( 'hex' );
            var witnessscript = prepCoinflip( player1Hash, player2Hash, player1Pubkey, player2Pubkey, blocks_to_wait );
            console.log( "witness script:", witnessscript );
            var p2wsh = bitcoinjs.payments.p2wsh({redeem: {output: witnessscript, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
            console.log( p2wsh.address );
            var outputscript = "00" + bitcoinjs.crypto.sha256( witnessscript ).toString('hex');

            var psbt = new bitcoinjs.Psbt({network: bitcoinjs.networks.testnet});
            //psbt.setLocktime( timelock );
            psbt
              .addInput({
                hash: txid,
                index: txindex,
                sequence: 0xfffffffe,
                witnessUtxo: {
                          script: buffer.Buffer.from('0020' +
                                    bitcoinjs.crypto.sha256( buffer.Buffer.from( witnessscript, 'hex' ) ).toString( 'hex' ),
                                    'hex' ),
                          value: original_quantity_of_sats
                },
                witnessScript: buffer.Buffer.from( witnessscript, 'hex' )
              });
            psbt
                .addOutput({
                  address: useraddress,
                  value: new_quantity_of_sats,
                });
            psbt.signInput( 0, bitcoinjs.ECPair.fromPrivateKey( buffer.Buffer.from( player1Privkey, "hex" ) ) );

            var getFinalScripts = ( txindex, input, script) => {
              // Step 1: Check to make sure the meaningful locking script matches what you expect.
              var decompiled = bitcoinjs.script.decompile( script )
              if ( !decompiled || decompiled[0] !== bitcoinjs.opcodes.OP_TOALTSTACK ) {
                throw new Error( `Can not finalize input #${txindex}` )
              }

              // Step 2: Create final scripts
              var witnessStackPlayer1Branch = bitcoinjs.payments.p2wsh({
                  redeem: {
                      output: script,
                      input: bitcoinjs.script.compile([
                              input.partialSig[0].signature,
                              buffer.Buffer.from( player1Preimage, 'hex' ),
                              buffer.Buffer.from( player2Preimage, 'hex' ),
                      ]),
                  }
              });
              console.log('Player 1 branch witness stack:')
              console.log(witnessStackPlayer1Branch.witness.map(x => x.toString('hex')))
              return {
                  finalScriptWitness: witnessStackToScriptWitness( witnessStackPlayer1Branch.witness )
              }
            }
            psbt.finalizeInput( 0, getFinalScripts );
            setTimeout( function() {console.log( psbt.extractTransaction().toHex() );}, 1000 );
        }
        function player2WonCoinflip( txid, txindex, original_quantity_of_sats, new_quantity_of_sats, player2Privkey, player2Pubkey, player1Pubkey, randomPreimage1, randomPreimage2, blocks_to_wait, useraddress, player1Hash, player2Hash ) {
                    var witnessscript = prepCoinflip( player1Hash, player2Hash, player1Pubkey, player2Pubkey, blocks_to_wait );
                    console.log( "witness script:", witnessscript );
                    var p2wsh = bitcoinjs.payments.p2wsh({redeem: {output: witnessscript, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
                    console.log( p2wsh.address );
                    var outputscript = "00" + bitcoinjs.crypto.sha256( witnessscript ).toString('hex');

                    var psbt = new bitcoinjs.Psbt({network: bitcoinjs.networks.testnet});
                    //psbt.setLocktime( timelock );
                    psbt
                      .addInput({
                        hash: txid,
                        index: txindex,
                        sequence: blocks_to_wait,
                        witnessUtxo: {
                                  script: buffer.Buffer.from('0020' +
                                            bitcoinjs.crypto.sha256( buffer.Buffer.from( witnessscript, 'hex' ) ).toString( 'hex' ),
                                            'hex'),
                                  value: original_quantity_of_sats
                        },
                        witnessScript: buffer.Buffer.from( witnessscript, 'hex' )
                      });
                    psbt
                        .addOutput({
                          address: useraddress,
                          value: new_quantity_of_sats,
                        });
                    psbt.signInput( 0, bitcoinjs.ECPair.fromPrivateKey( buffer.Buffer.from( player2Privkey, "hex" ) ) );

                    var getFinalScripts = ( txindex, input, script) => {
                      // Step 1: Check to make sure the meaningful locking script matches what you expect.
                      var decompiled = bitcoinjs.script.decompile( script )
                      if ( !decompiled || decompiled[0] !== bitcoinjs.opcodes.OP_TOALTSTACK ) {
                        throw new Error( `Can not finalize input #${txindex}` )
                      }

                      // Step 2: Create final scripts
                      var witnessStackPlayer2Branch = bitcoinjs.payments.p2wsh({
                          redeem: {
                              output: script,
                              input: bitcoinjs.script.compile([
                                      input.partialSig[0].signature,
                                      buffer.Buffer.from( randomPreimage1, 'hex' ),
                                      buffer.Buffer.from( randomPreimage2, 'hex' ),
                              ]),
                          }
                      });
                      console.log('Player 2 branch witness stack:')
                      console.log(witnessStackPlayer2Branch.witness.map(x => x.toString('hex')))
                      return {
                          finalScriptWitness: witnessStackToScriptWitness( witnessStackPlayer2Branch.witness )
                      }
                    }
                    psbt.finalizeInput( 0, getFinalScripts );
                    setTimeout( function() {console.log( psbt.extractTransaction().toHex() );}, 1000 );
        }

        function withdrawFromRevelationAddressAfterTimelockAsPlayer1( txid, txindex, original_quantity_of_sats, new_quantity_of_sats, player1Privkey, player2Pubkey, blocks_to_wait, player2Hash, useraddress ) {
            blocks_to_wait = Number( blocks_to_wait );
            var player1Pubkey = nobleSecp256k1.getPublicKey( player1Privkey, true );
            console.log( "ok time to pay attention" );
            console.log( player2Hash, player1Pubkey, player2Pubkey, blocks_to_wait );
            var witnessscript = reveal_and_redeem( player2Hash, player1Pubkey, player2Pubkey, blocks_to_wait );
            console.log( "witness script:", witnessscript );
            var p2wsh = bitcoinjs.payments.p2wsh({redeem: {output: witnessscript, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
            console.log( p2wsh.address );
            var outputscript = "00" + bitcoinjs.crypto.sha256( witnessscript ).toString('hex');

            var psbt = new bitcoinjs.Psbt({network: bitcoinjs.networks.testnet});
            //psbt.setLocktime( timelock );
            psbt
              .addInput({
                hash: txid,
                index: txindex,
                sequence: blocks_to_wait,
                witnessUtxo: {
                          script: buffer.Buffer.from('0020' +
                                    bitcoinjs.crypto.sha256( buffer.Buffer.from( witnessscript, 'hex' ) ).toString( 'hex' ),
                                    'hex'),
                          value: original_quantity_of_sats
                },
                witnessScript: buffer.Buffer.from( witnessscript, 'hex' )
              });
            psbt
                .addOutput({
                  address: useraddress,
                  value: new_quantity_of_sats,
                });
            psbt.signInput( 0, bitcoinjs.ECPair.fromPrivateKey( buffer.Buffer.from( player1Privkey, "hex" ) ) );

            var getFinalScripts = ( txindex, input, script) => {
              // Step 1: Check to make sure the meaningful locking script matches what you expect.
              var decompiled = bitcoinjs.script.decompile( script )
              if ( !decompiled || decompiled[0] !== bitcoinjs.opcodes.OP_SIZE ) {
                throw new Error( `Can not finalize input #${txindex}` )
              }

              // Step 2: Create final scripts
              var witnessStackPlayer1Branch = bitcoinjs.payments.p2wsh({
                  redeem: {
                      output: script,
                      input: bitcoinjs.script.compile([
                              input.partialSig[0].signature,
                      ]),
                  }
              });
              console.log('Player 1 branch witness stack:')
              console.log(witnessStackPlayer1Branch.witness.map(x => x.toString('hex')))
              return {
                  finalScriptWitness: witnessStackToScriptWitness( witnessStackPlayer1Branch.witness )
              }
            }
            psbt.finalizeInput( 0, getFinalScripts );
            setTimeout( function() {console.log( psbt.extractTransaction().toHex() );}, 1000 );
        }

        function revealPreimage( player2Preimage, player1Pubkey, player2Privkey, blocks_to_wait, txid, txindex, original_quantity_of_sats, new_quantity_of_sats, useraddress ) {
            var player2Pubkey = nobleSecp256k1.getPublicKey( player2Privkey, true );
            blocks_to_wait = Number( blocks_to_wait );
            var player2Hash = bitcoinjs.crypto.hash160( buffer.Buffer.from( player2Preimage, 'hex' ) ).toString( 'hex' );
            var witnessscript = reveal_and_redeem( player2Hash, player1Pubkey, player2Pubkey, blocks_to_wait );
            console.log( "witness script:", witnessscript );
            var p2wsh = bitcoinjs.payments.p2wsh({redeem: {output: witnessscript, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
            console.log( p2wsh.address );
            var outputscript = "00" + bitcoinjs.crypto.sha256( witnessscript ).toString('hex');

            var psbt = new bitcoinjs.Psbt({network: bitcoinjs.networks.testnet});
            //psbt.setLocktime( timelock );
            psbt
              .addInput({
                hash: txid,
                index: txindex,
                sequence: 0xfffffffe,
                witnessUtxo: {
                          script: buffer.Buffer.from('0020' +
                                    bitcoinjs.crypto.sha256( buffer.Buffer.from( witnessscript, 'hex' ) ).toString( 'hex' ),
                                    'hex'),
                          value: original_quantity_of_sats
                },
                witnessScript: buffer.Buffer.from( witnessscript, 'hex' )
              });
            psbt
                .addOutput({
                  address: useraddress,
                  value: new_quantity_of_sats,
                });
            psbt.signInput( 0, bitcoinjs.ECPair.fromPrivateKey( buffer.Buffer.from( player2Privkey, "hex" ) ) );

            var getFinalScripts = ( txindex, input, script) => {
              // Step 1: Check to make sure the meaningful locking script matches what you expect.
              var decompiled = bitcoinjs.script.decompile( script )
              if ( !decompiled || decompiled[0] !== bitcoinjs.opcodes.OP_SIZE ) {
                throw new Error( `Can not finalize input #${txindex}` )
              }

              // Step 2: Create final scripts
              var witnessStackPlayer2Branch = bitcoinjs.payments.p2wsh({
                  redeem: {
                      output: script,
                      input: bitcoinjs.script.compile([
                              input.partialSig[0].signature,
                              buffer.Buffer.from( player2Preimage, 'hex' ),
                      ]),
                  }
              });
              console.log('Player 2 branch witness stack:')
              console.log(witnessStackPlayer2Branch.witness.map(x => x.toString('hex')))
              return {
                  finalScriptWitness: witnessStackToScriptWitness( witnessStackPlayer2Branch.witness )
              }
            }
            psbt.finalizeInput( 0, getFinalScripts );
            setTimeout( function() {console.log( psbt.extractTransaction().toHex() );}, 1000 );
        }

        function getPreimageFromTransactionThatSpendsAnHTLC( txid, pmthash ) {
                return new Promise( function( resolve, reject ) {
                        var xhttp = new XMLHttpRequest();
                        xhttp.onreadystatechange = function() {
                                if (this.readyState == 4 && this.status == 200) {
                                        var json = JSON.parse( xhttp.responseText );
                                        var i; for ( i=0; i<json[ "vin" ].length; i++ ) {
                                                var j; for ( j=0; j<json[ "vin" ][ i ][ "witness" ].length; j++ ) {
                                                        if ( bitcoinjs.crypto.hash160( buffer.Buffer.from( json[ "vin" ][ i ][ "witness" ][ j ], "hex" ) ).toString( "hex" ) == pmthash ) {
                                                                resolve( json[ "vin" ][ i ][ "witness" ][ j ] );
                                                        }
                                                }
                                        }
                                        resolve( "" );
                                }
                        };
                        xhttp.open("GET", "https://blockstream.info/testnet/api/tx/" + txid, true);
                        xhttp.send();
                });
        }
        function pushBTCpmt( rawtx ) {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                        if ( this.readyState == 4 && ( this.status == 200 || this.status == 201 ) ) {
                                var json = JSON.parse( this.responseText );
                                console.log( json );
                                console.log( "Your transaction was broadcasted, your txid is: " + json[ "tx" ][ "hash" ] );
                        }
                };
                xhttp.open( "POST", "https://api.blockcypher.com/v1/btc/test3/txs/push", true );
                xhttp.setRequestHeader( "Content-type", "text/plain" );
                xhttp.send( '{"tx":"' + rawtx + '"}' );
        }
        function getBlockheight() {
            return new Promise( function( resolve, reject ) {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                        if ( this.readyState == 4 && this.status == 200 ) {
                                var blockheight = Number( xhttp.responseText );
                                resolve( blockheight );
                        }
                };
                xhttp.open( "GET", "https://blockstream.info/testnet/api/blocks/tip/height", true );
                xhttp.send();
            });
        }
        function getBlockWhenTransactionWasMined( txid ) {
            return new Promise( function( resolve, reject ) {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                    if ( this.readyState == 4 && this.status == 200 ) {
                        var json = JSON.parse( xhttp.responseText );
                        if ( json[ "status" ][ "confirmed" ] ) {
                            resolve( Number( json[ "status" ][ "block_height" ] ) );
                        } else {
                            resolve( "0".toString() );
                        }
                    }
                };
                xhttp.open( "GET", "https://blockstream.info/testnet/api/tx/" + txid, true );
                xhttp.send();
            });
        }
        function getTransactionsInvolvingAddress( address ) {
                return new Promise( function( resolve, reject ) {
                        var xhttp = new XMLHttpRequest();
                        xhttp.onreadystatechange = function() {
                                if (this.readyState == 4 && this.status == 200) {
                                        var json = JSON.parse( xhttp.responseText );
                                        var txs = [];
                                        var i; for ( i=0; i<json.length; i++ ) {
                                                txs.push( json[ i ][ "txid" ] );
                                        }
                                        resolve( JSON.stringify( txs ) );
                                }
                        };
                        xhttp.open("GET", "https://blockstream.info/testnet/api/address/" + address + "/txs", true);
                        xhttp.send();
                });                
        }

        function waitSomeSeconds( num ) {
          var num = num.toString() + "000";
          num = Number( num );
          return new Promise( function( resolve, reject ) {
            setTimeout( function() { resolve( "I am waiting ten seconds because sometimes esplora updates intermittently where it knows a txid is associated with an address but does not have the info for that txid yet" ); }, num );
          });
        }

        function takeTxsAndGetPreimageFromThem( txs, hash ) {
            return new Promise( async function( resolve, reject ) {
                if ( txs.length > 1 ) {
                        console.log( "here comes the ten second timeout" );
                        var timeout = await waitSomeSeconds( 10 );
                        console.log( "ok the ten second timeout is done, let's continue" );
                        txs.forEach( async function( tx ) {
                            console.log( tx );
                            var possible_preimage = await getPreimageFromTransactionThatSpendsAnHTLC( tx, hash );
                            console.log( "here is the possible preimage I got (remember that it might be blank):", possible_preimage );
                            console.log( "if it is blank I will ignore it" );
                            if ( possible_preimage ) {
                                if ( possible_preimage.length == 32 || possible_preimage.length == 34 ) {
                                    console.log( "it was the right size so I will now return it (by the way, this is it:", possible_preimage );
                                    resolve( possible_preimage );
                                }
                            }
                        });
                } else {
                        resolve( "" );
                }
            });
        }

        async function getSweepablePreimageFromAllPossibilities( address, hash ) {
            return new Promise( async function( resolve, reject ) {
                var txs = await getTransactionsInvolvingAddress( address );
                var txs = JSON.parse( txs );
                var preimage = "";
                console.log( "Ok I am trying to get the preimage for this hash:", hash );
                console.log( "here are the transactions I can search for it in (remember that it might be blank, in which case I will just rerun in a bit):" );
                preimage += await takeTxsAndGetPreimageFromThem( txs, hash )
                console.log( "the preimage I will return is", preimage );
                resolve( preimage );
            });
        }

        function addressOnceSentMoney( address ) {
            return new Promise( function( resolve, reject ) {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                    if ( this.readyState == 4 && this.status == 200 ) {
                        var json = JSON.parse( xhttp.responseText );
                        if ( json[ "chain_stats" ][ "spent_txo_count" ] > 0 || json[ "mempool_stats" ][ "spent_txo_count" ] > 0 ) {
                            resolve( true );
                        }
                        resolve( false );
                    }
                };
                xhttp.open( "GET", "https://blockstream.info/testnet/api/address/" + address, true );
                xhttp.send();
            });
        }
</script>
<script>
        function addressOnceHadMoney( address ) {
            return new Promise( function( resolve, reject ) {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                    if ( this.readyState == 4 && this.status == 200 ) {
                        var json = JSON.parse( xhttp.responseText );
                        if ( json[ "chain_stats" ][ "funded_txo_count" ] > 0 ) {
                            resolve( true );
                        }
                        resolve( false );
                    }
                };
                xhttp.open( "GET", "https://blockstream.info/testnet/api/address/" + address, true );
                xhttp.send();
            });
        }
</script>
<script>
        function putOfferOnNostr( offer ) {
                console.log( "note: '" + offer + "'" );
                var now = Math.floor( ( new Date().getTime() ) / 1000 );
                console.log( now );
                var newevent = [
                        0,
                        pubKeyMinus2,
                        now,
                        40,
                        [],
                        offer
                ];
                var message = JSON.stringify( newevent );
                console.log( "message: '" + message + "'" );
                var msghash = bitcoinjs.crypto.sha256( message ).toString( 'hex' );
                console.log( "msghash: '" + msghash + "'" );
                nobleSecp256k1.schnorr.sign( msghash, privKey ).then( 
                        value => { 
                                sig = value;
                                console.log( "the sig is:", sig );
                                nobleSecp256k1.schnorr.verify( 
                                        sig,
                                        msghash,
                                        pubKeyMinus2
                                ).then(
                                        value => { 
                                                console.log( "this should say true if the signature is valid for the above pubkey over the message", value );
                                                if ( value ) {
                                                        var fullevent = {
                                                                "id": msghash,
                                                                "pubkey": pubKeyMinus2,
                                                                "created_at": now,
                                                                "kind": 40,
                                                                "tags": [],
                                                                "content": offer,
                                                                "sig": sig
                                                        }
                                                        var sendable = [ "EVENT", fullevent ];
                                                        sessionStorage.sendable = JSON.stringify( sendable );
                                                        console.log( "here is what you will send:", sendable );
                                                        socket.send( '["EVENT",' + JSON.stringify( JSON.parse( sessionStorage.sendable )[ 1 ] ) + ']' );
                                                 }
                                        }
                               );
                        }
                );
        }
        function makeNote( note ) {
                console.log( "note: '" + note + "'" );
                var now = Math.floor( ( new Date().getTime() ) / 1000 );
                console.log( now );
                var newevent = [
                        0,
                        pubKeyMinus2,
                        now,
                        1,
                        [],
                        note
                ];
                var message = JSON.stringify( newevent );
                console.log( "message: '" + message + "'" );
                var msghash = bitcoinjs.crypto.sha256( message ).toString( 'hex' );
                console.log( "msghash: '" + msghash + "'" );
                nobleSecp256k1.schnorr.sign( msghash, privKey ).then( 
                        value => { 
                                sig = value;
                                console.log( "the sig is:", sig );
                                nobleSecp256k1.schnorr.verify( 
                                        sig,
                                        msghash,
                                        pubKeyMinus2
                                ).then(
                                        value => { 
                                                console.log( "this should say true if the signature is valid for the above pubkey over the message", value );
                                                if ( value ) {
                                                        var fullevent = {
                                                                "id": msghash,
                                                                "pubkey": pubKeyMinus2,
                                                                "created_at": now,
                                                                "kind": 1,
                                                                "tags": [],
                                                                "content": note,
                                                                "sig": sig
                                                        }
                                                        var sendable = [ "EVENT", fullevent ];
                                                        sessionStorage.sendable = JSON.stringify( sendable );
                                                        socket.send( '["EVENT",' + JSON.stringify( JSON.parse( sessionStorage.sendable )[ 1 ] ) + ']' );
                                                 }
                                        }
                               );
                        }
                );
        }
        function makePrivateNote( note, recipientpubkey ) {
                console.log( "note: '" + note + "'" );
                var now = Math.floor( ( new Date().getTime() ) / 1000 );
                console.log( now );
                var privatenote = encrypt( privKey, recipientpubkey, note );
                var newevent = [
                        0,
                        pubKeyMinus2,
                        now,
                        4,
                        [['p', recipientpubkey]],
                        privatenote
                ];
                var message = JSON.stringify( newevent );
                console.log( "message: '" + message + "'" );
                var msghash = bitcoinjs.crypto.sha256( message ).toString( 'hex' );
                console.log( "msghash: '" + msghash + "'" );
                nobleSecp256k1.schnorr.sign( msghash, privKey ).then(
                        value => {
                                sig = value;
                                console.log( "the sig is:", sig );
                                nobleSecp256k1.schnorr.verify(
                                        sig,
                                        msghash,
                                        pubKeyMinus2
                                ).then(
                                        value => {
                                                console.log( "this should say true if the signature is valid for the above pubkey over the message", value );
                                                if ( value ) {
                                                        var fullevent = {
                                                                "id": msghash,
                                                                "pubkey": pubKeyMinus2,
                                                                "created_at": now,
                                                                "kind": 4,
                                                                "tags": [['p', recipientpubkey]],
                                                                "content": privatenote,
                                                                "sig": sig
                                                        }
                                                        var sendable = [ "EVENT", fullevent ];
                                                        sessionStorage.sendable = JSON.stringify( sendable );
                                                        socket.send( '["EVENT",' + JSON.stringify( JSON.parse( sessionStorage.sendable )[ 1 ] ) + ']' );
                                                 }
                                        }
                               );
                        }
                );
        }
        function encrypt( privkey, pubkey, text ) {
          console.log( "recipient pubkey (because I keep getting an error that it is not real):", pubkey );
          var key = nobleSecp256k1.getSharedSecret( privkey, '02' + pubkey, true ).substring( 2 );

          var iv = window.crypto.getRandomValues( new Uint8Array(16) );
          var cipher = browserifyCipher.createCipheriv(
            'aes-256-cbc',
            buffer.Buffer.from( key, 'hex' ),
            iv
          );
          var encryptedMessage = cipher.update( text, "utf8", "base64" );
          emsg = encryptedMessage + cipher.final( "base64" );

          return emsg + "?iv=" + buffer.Buffer.from( iv.buffer ).toString( "base64");
        }

        function decrypt( privkey, pubkey, ciphertext ) {
          var [ emsg, iv ] = ciphertext.split( "?iv=" );
          var key = nobleSecp256k1.getSharedSecret( privkey, '02' + pubkey, true ).substring( 2 );

          var decipher = browserifyCipher.createDecipheriv(
            'aes-256-cbc',
            buffer.Buffer.from( key, "hex" ),
            buffer.Buffer.from( iv, "base64" )
          );
          var decryptedMessage = decipher.update( emsg, "base64" );
          dmsg = decryptedMessage + decipher.final( "utf8" );

          return dmsg;
        }
        sessionStorage[ "maximum" ] = 10000;
        sessionStorage[ "minimum" ] = 1000;
</script>
</body>
</html>
