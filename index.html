<!DOCTYPE html>
<html>
<head>
<script src="https://bitcoincore.tech/apps/bitcoinjs-ui/lib/bitcoinjs-lib.js"></script>
<script src="https://bundle.run/varuint-bitcoin@1.1.2"></script>
<script src="https://bundle.run/bip39@3.0.4"></script>
<script src="https://bundle.run/bip32@2.0.6"></script>
<script src="https://bundle.run/buffer@6.0.3"></script>
<script src="https://bundle.run/noble-secp256k1@1.2.14"></script>
<script src="https://bundle.run/browserify-cipher@1.0.1"></script>
<script>
        function computeRawPrivkey( node ) {
                return bitcoinjs.ECPair.fromPrivateKey( node.privateKey, { network: bitcoinjs.networks.mainnet } );
        }
</script>
<script>
        function getPrivkeyHex( backupwords, path, index ) {
                var seed = bip39.mnemonicToSeedSync( backupwords );
                var node = bip32.fromSeed( seed );
                var path = "m/" + path + "/" + index;
                var root = node;
                var child = root.derivePath( path );
                return computeRawPrivkey( child );
        }
</script>
<script>
        function toHexString(byteArray) {
                return Array.from(byteArray, function(byte) {
                        return ('0' + (byte & 0xFF).toString(16)).slice(-2);
                }).join('');
        }
</script>
<script>
        var backupwords = bip39.generateMnemonic();
        var path = 0;
        var index = 1;
        var privKey = getPrivkeyHex( backupwords, path, index );
        privKey = privKey.__D.toString( 'hex' );
        var pubKey = nobleSecp256k1.getPublicKey( privKey, true );
        var pubKeyMinus2 = pubKey.substring( 2 );
</script>
<style>
        * {
                box-sizing: border-box;
                margin: 0px;
                padding: 0px;
        }
        .status-update::before {
                content: '$ ';
        }
        .status-update {
                margin-bottom: 15px;
        }
</style>
</head>
<body>
        <h1>This is a work in progress, it doesn't always work yet</h1>
        <div id="orderbook-wrapper">
                <h1 style="display: inline-block; vertical-align: middle;">Orderbook</h1>
                <p style="display: inline-block; vertical-align: middle;"><button id="new-coinflip-btn">Create new coinflip</button></p>
                <div id="orderbook" style="font-family: monospace;">
                        <div style="border: 1px solid black; display: inline-block; width: 100px; text-align: center;">Player 1</div><div style="border: 1px solid black; border-left: 0px; display: inline-block; width: 100px; text-align: center;">Amount</div><div style="border: 1px solid black; border-left: 0px; display: inline-block; width: 180px; text-align: center;">Expiry</div><div style="border: 1px solid black; border-left: 0px; display: inline-block; width: 74px; text-align: center;">Accept?</div><br>
                        <div id="empty-msg">The orderbook is currently empty, try creating a coinflip</div>
                </div>
        </div>
        <div id="creation-and-status-wrapper" style="display: none;">
                <div id="creation-wrapper">
                        <h1>Create a coinflip</h1>
                        <p>This coinflip site uses a remote coinflipping technique invented in 1981 by Michael Blum. You pick Heads or Tails and commit to it via a cryptographic hash which you will soon publish on bitcoin's blockchain. Your opponent guesses if you picked Heads or Tails, and you cannot change your choice after he or she guesses because the blockchain is irreversible. If your opponent guesses correctly, he or she wins the bet amount, otherwise you win. The rules of the game are enforced by a bitcoin smart contract. There are no third parties involved, only you and your opponent.</p>
                        <p>Try clicking Heads or Tails below. You can see how your hash will appear on the blockchain, it is displayed as a 40 character string under the coin. Be aware that every time you play the game the hashes will be different because they are not literally a hash of the word Heads or the word Tails. The strings are hashes of random numbers that are either 16 bytes long (Heads) or 17 bytes long (Tails).</p>
                        <p>When you are ready to commit to your coinflip, click Create. This website will then create an offer and wait for someone to accept it. You'll also get a link you can share if you want to invite someone to accept your coinflip. You won't need to pay money to commit your coinflip to the blockchain til someone accepts your offer. You can also abort at any time except if your opponent wins (which is sort of an auto-abort situation anyway, one where you also can't get your money back).</p>
                        <p>Bitcoin address where you'd like to receive your opponent's money (if you win)</p>
                        <p><input type="text" id="address" placeholder="tb1a9baasdf0bo0hmb8fsad6tuij76asdf23abbsdf" style="width: 100%; max-width: 350px;" /></p>
                        <p>Amount of sats to bet</p>
                        <p><input type="text" id="amount" placeholder="min 1000, max 10000" style="width: 100%; max-width: 350px;" /></p>
                        <p><button id="heads-btn">Heads</button></p>
                        <p><button id="tails-btn">Tails</button></p>
                        <p><button id="random-btn">Random</button></p>
                        <p><button id="create-btn">Create</button></p>
                        <img style="display: block;" id="obverse" src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/Washington_Quarter_Silver_1944S_Obverse.png/477px-Washington_Quarter_Silver_1944S_Obverse.png" />
                        <img style="display: none;" id="reverse" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3c/Washington_Quarter_Silver_1944S_Reverse.png/481px-Washington_Quarter_Silver_1944S_Reverse.png" />
                        <input id="hash" type="text" disabled="true" style="width: 100%; max-width: 350px; background-color: #cccccc; font-family: monospace;" />
                </div>
                <div id="status-updates-wrapper">
                        <h1>Current status (follow any instructions that appear in the top line)</h1>
                        <div id="status-updates" style="background-color: black; color: green; font-weight: bold; height: 300px; line-height: 25px; padding: 10px; overflow-x: scroll;">
                        </div>
                        <h1>Upcoming statuses (don't follow any of the instructions in this box til they appear at the top of Current Status)</h1>
                        <div id="upcoming-statuses" style="background-color: black; color: green; font-weight: bold; height: 300px; line-height: 25px; padding: 10px; overflow-x: scroll;">
                                <div id="awaiting-initiation-status" class="status-update">
                                        Waiting for you to put a coinflip offer on the orderbook
                                </div>
                                <div id="awaiting-acceptance-status" class="status-update">
                                        Waiting for someone to accept your offer or for your offer to expire
                                </div>
                                <div id="awaiting-ack-status" class="status-update">
                                        Waiting for you to acknowledge a user who accepted your coinflip or for your offer to expire
                                </div>
                                <div id="awaiting-opponents-deposit-status" class="status-update">
                                        Waiting for your opponent to deposit money into their deposit address or for 3 bitcoin blocks to pass by for auto-abortion
                                </div>
                                <div id="awaiting-your-deposit-status" class="status-update">
                                        Waiting for you to deposit money into your deposit address or for 4 bitcoin blocks to pass by for auto-abortion
                                </div>
                                <div id="awaiting-opponents-guess-status" class="status-update">
                                        Waiting for your opponent to reveal their guess (Heads or Tails) or for 4 bitcoin blocks to pass by for auto-abortion (and recovery of the money you deposited into your deposit address) -- remember that your opponent may wait for your transaction to confirm 1 to 4 times (which can take 10 to 40 minutes) before revealing their guess
                                </div>
                                <div id="checking-who-won-status" class="status-update">
                                        Checking if your opponent guessed correctly or not
                                </div>
                                <div id="withdrawing-or-acquiescing-status" class="status-update">
                                        Withdrawing your money (if you won) or acquiescing to your opponent's victory (if your opponent won)
                                </div>
                                <div id="finished-status" class="status-update">
                                        Finished
                                </div>
                        </div>
                        <div id="invisible-upcoming-statuses" style="display: none;">
                                <div id="link-to-this-page-status" class="status-update">
                                        With this link you can invite someone to take your coinflip offer: <span id="status-link"></span> Only invite one person per game otherwise you can lose your money because information about the choices you made in this game will be revealed whether you win or lose, and that information can be used by other people to steal your money.
                                </div>
                                <div id="deposit-into-the-revelation-address-status" class="status-update">
                                        Deposit *exactly* <span id="status-amount"></span> sats into this address: <span id="status-revelation-address"></span>. If you send the wrong amount, even by a little bit, you may automatically lose your money. Also, be sure to keep your browser open til the game ends (which is 4 bitcoin blocks after you make your deposit, i.e. hopefully around 40 minutes after you make your deposit). If you close your browser before you withdraw your winnings, you'll abort the protocol and may lose money to your opponent, even if they guessed Heads or Tails wrong. Also, your private keys and cookies could be lost, and you can lose money that way too.
                                </div>
                                <div id="your-deposit-detected" class="status-update">
                                        Your deposit was detected – waiting for your opponent to reveal his guess – if your opponent aborts at this point, you’ll get your deposit back in 4 blocks, minus a bit in transaction fees.
                                </div>
                                <div id="opponents-deposit-detected" class="status-update">
                                        Your opponent's deposit was detected but has not confirmed yet. Wait for it to get at least one confirmation before continuing. Do not wait for more than 4 confirmations or your opponent may abort. (If you watch this screen, it will auto update with new instructions once it detects that your transaction got 1 confirmation.)
                                </div>
                                <div id="opponents-guess-detected" class="status-update">
                                        Your opponent revealed their guess
                                </div>
                                <div id="aborted-due-to-timeout-opponents-fault" class="status-update">
                                        Aborted because your opponent took too long
                                </div>
                                <div id="aborted-due-to-timeout-your-fault" class="status-update">
                                        Aborted because you took too long
                                </div>
                                <div id="aborted-due-to-wrong-amount-opponents-fault" class="status-update">
                                        Aborted because your opponent put the wrong amount in their deposit address
                                </div>
                                <div id="aborted-due-to-wrong-amount-your-fault" class="status-update">
                                        Aborted because you put the wrong amount in your deposit address
                                </div>
                                <div id="oh-no-you-lost" class="status-update">
                                        Oh no! You lost. :(
                                </div>
                                <div id="yay-you-won" class="status-update">
                                        Yay! You won! Your winnings are now being withdrawn to your bitcoin address.
                                </div>
                        </div>
                </div>
                <img style="display: block; cursor: pointer;" id="abort" src="https://brilliancebitcoin.github.io/coinflip/abort-sign.png" />
        </div>
<script>
        window.onload = function() {
                if ( !sessionStorage[ "sixteenBytePreimage" ] || sessionStorage[ "sixteenBytePreimage" ] == "" ) {
                        var sixteenBytePreimage = get16BytePreimage();
                        sessionStorage[ "sixteenBytePreimage" ] = sixteenBytePreimage;
                }
                document.getElementById( "hash" ).value = bitcoinjs.crypto.hash160( buffer.Buffer.from( sessionStorage[ "sixteenBytePreimage" ], "hex" ) ).toString( "hex" );
                document.getElementById( "status-updates" ).prepend( document.getElementById( "awaiting-initiation-status" ) );
        }
</script>
<script>
        document.getElementById( "new-coinflip-btn" ).addEventListener( "click", function() {
                document.getElementById( "orderbook-wrapper" ).style.display = "none";
                document.getElementById( "creation-and-status-wrapper" ).style.display = "block";
        });
        document.getElementById( "heads-btn" ).addEventListener( "click", function() {
                document.getElementById( "obverse" ).style.display = "block";
                document.getElementById( "reverse" ).style.display = "none";
                if ( !sessionStorage[ "sixteenBytePreimage" ] || sessionStorage[ "sixteenBytePreimage" ] == "" ) {
                        var sixteenBytePreimage = get16BytePreimage();
                        sessionStorage[ "sixteenBytePreimage" ] = sixteenBytePreimage;
                }
                document.getElementById( "hash" ).value = bitcoinjs.crypto.hash160( buffer.Buffer.from( sessionStorage[ "sixteenBytePreimage" ], "hex" ) ).toString( "hex" );
        });
        document.getElementById( "tails-btn" ).addEventListener( "click", function() {
                document.getElementById( "obverse" ).style.display = "none";
                document.getElementById( "reverse" ).style.display = "block";
                if ( !sessionStorage[ "seventeenBytePreimage" ] || sessionStorage[ "seventeenBytePreimage" ] == "" ) {
                        var seventeenBytePreimage = get17BytePreimage();
                        sessionStorage[ "seventeenBytePreimage" ] = seventeenBytePreimage;
                }
                document.getElementById( "hash" ).value = bitcoinjs.crypto.hash160( buffer.Buffer.from( sessionStorage[ "seventeenBytePreimage" ], "hex" ) ).toString( "hex" );
        });
        document.getElementById( "random-btn" ).addEventListener( "click", function() {
                var rand = Math.floor( Math.random() * 2 );
                console.log( rand );
                if ( rand == 0 ) {
                        document.getElementById( "heads-btn" ).click();
                } else {
                        document.getElementById( "tails-btn" ).click();
                }
        });
        document.getElementById( "abort" ).addEventListener( "click", function() {
                var conf_message = "If you abort at this stage you won't lose any money and everything will reset. Please click ok if that is what you want or click cancel to continue playing the game.";
                if ( confirm( conf_message ) ) {
                        sessionStorage.clear();
                        localStorage.clear();
                        window.location.reload();
                }
        });
        document.getElementById( "create-btn" ).addEventListener( "click", function() {
                var amount = document.getElementById( "amount" ).value;
                if ( Number( amount ) < 1000 || Number( amount ) > 10000 ) {
                        alert( "Minimum amount is 1000 sats, maximum is 10000 sats" );
                } else {
                        var heads_or_tails = ( document.getElementById( "obverse" ).style.display == "block" ) ? "heads":"tails";
                        if ( heads_or_tails == "heads" ) {
                                var preimage = sessionStorage[ "sixteenBytePreimage" ];
                        } else {
                                var preimage = sessionStorage[ "seventeenBytePreimage" ];
                        }
                        document.getElementById( "creation-wrapper" ).style.display = "none";
                        document.getElementById( "status-updates" ).prepend( document.getElementById( "awaiting-acceptance-status" ) );
                        createOffer( amount, preimage );
                        document.getElementById( "status-updates" ).prepend( document.getElementById( "link-to-this-page-status" ) );
                }
        });
        function isJsonString( str ) {
            try {
                JSON.parse( str );
            } catch ( e ) {
                return false;
            }
            return true;
        }
        function processOffer( offer, id, player_ones_nostr_pubkey ) {
                if ( isJsonString( offer ) && JSON.parse( offer )[ "msgtype" ] && JSON.parse( offer )[ "hash" ] && JSON.parse( offer )[ "amount" ] && JSON.parse( offer )[ "pubkey" ] && JSON.parse( offer )[ "pubkeyForRevelationAddress" ] && JSON.parse( offer )[ "blocks_to_wait" ] && JSON.parse( offer )[ "blocks_to_wait_for_revelation_address" ] &&  JSON.parse( offer )[ "offer_expires" ] ) {
                        var expiry = JSON.parse( offer )[ "offer_expires" ];
                        var player1 = player_ones_nostr_pubkey;
                        var amount = JSON.parse( offer )[ "amount" ];
                        var current_time = Math.floor( Date.now() / 1000 );
                        if ( expiry > current_time ) {
                                document.getElementById( "empty-msg" ).style.display = "none";
                                document.getElementById( "orderbook" ).innerHTML += `<div style="border: 1px solid black; display: inline-block; width: 100px; text-align: center;">` + player1.substring( 0, 12 ) +  `</div><div style="border: 1px solid black; border-left: 0px; display: inline-block; width: 100px; text-align: center;">` + amount.toString() + " sats" + `</div><div style="border: 1px solid black; border-left: 0px; display: inline-block; width: 180px; text-align: center;">` + new Date( expiry * 1000 ).toLocaleDateString() + " " + new Date( expiry * 1000 ).toLocaleTimeString() + `</div><a href="/coinflip/offer.html?id=` + id + `"><div style="border: 1px solid green; border-radius: 5px; width: 60px; margin-left: 7px; display: inline-block; text-align: center; background-color: lightgreen; color: white; font-weight: bold; cursor: pointer;">Accept</div></a><br>`;
                        }

                }
        }
</script>
<script>
        function normalizeRelayURL(e){let[t,...r]=e.trim().split("?");return"http"===t.slice(0,4)&&(t="ws"+t.slice(4)),"ws"!==t.slice(0,2)&&(t="wss://"+t),t.length&&"/"===t[t.length-1]&&(t=t.slice(0,-1)),[t,...r].join("?")}
        var relay = "wss://nostr-relay.wlvs.space";
        relay = normalizeRelayURL( relay );
        var socket = new WebSocket( relay );
        var filter = {
                "#p": [
                        pubKeyMinus2
                ]
        };
        var subscription = [ "REQ", "get-self-references", filter ];
        subscription = JSON.stringify( subscription );
        sessionStorage[ "selfsubscription" ] = subscription;
        setTimeout( function() {socket.send( sessionStorage[ "selfsubscription" ] );}, 1000 );

        var filter = {
                "kinds": [
                        40
                ]
        };
        var subscription2 = [ "REQ", "get-kind-forty", filter ];
        subscription2 = JSON.stringify( subscription2 );
        sessionStorage[ "kindfortysub" ] = subscription2;
        setTimeout( function() {socket.send( sessionStorage[ "kindfortysub" ] );}, 1000 );

        function subscribe( pubkey ) {
          var filter = {
                  "authors": [
                          pubkey
                  ]
          };
          var subscription = [ "REQ", "my-sub", filter ];
          subscription = JSON.stringify( subscription );
          sessionStorage.subscription = subscription;
          socket.send( sessionStorage.subscription );
        }

        socket.addEventListener( 'open', function( event ) {
                console.log( "connected to nostr relay " + relay );
        });

        // Listen for messages
        socket.addEventListener( 'message', function( event ) {
                var event = JSON.parse( event.data );
                if ( event[ 2 ].kind == 4 ) {
                        var i; for ( i=0; i<event[ 2 ].tags.length; i++ ) {
                                        if ( event[ 2 ].tags[ i ] && event[ 2 ].tags[ i ][ 1 ] ) {
                                                        var recipient = event[ 2 ].tags[ i ][ 1 ];
                                                        if ( recipient == pubKeyMinus2 ) {
                                                                        var decrypted_message = decrypt( privKey, event[ 2 ].pubkey, event[ 2 ].content );
                                                                        console.log( decrypted_message + " (sent privately by " + event[ 2 ].pubkey + ")" );
                                                                        decideMessageTypeAndNextSteps( decrypted_message, event[ 2 ].pubkey );
                                                        } else if ( event[ 2 ].pubkey == pubKeyMinus2 ) {
                                                                        console.log( decrypt( privKey, recipient, event[ 2 ].content ) + " (sent privately by " + event[ 2 ].pubkey + ")" );
                                                        }
                                        }
                        }
                } else if ( event[ 2 ].kind == 1 ) {
                        console.log( event[ 2 ].content + " (sent publicly by " + event[ 2 ].pubkey + ")" );
                } else if ( event[ 2 ].kind == 40 ) {
                        processOffer( event[ 2 ].content, event[ 2 ].id, event[ 2 ].pubkey );
                }
        });
</script>
<script>
        function witnessStackToScriptWitness(witness) {
          let buffer2 = buffer.Buffer.allocUnsafe(0);
          function writeSlice(slice) {
            buffer2 = buffer.Buffer.concat([buffer2, buffer.Buffer.from(slice)]);
          }
          function writeVarInt(i) {
            const currentLen = buffer2.length;
            const varintLen = varuintBitcoin.encodingLength(i);
            buffer2 = buffer.Buffer.concat([buffer2, buffer.Buffer.allocUnsafe(varintLen)]);
            varuintBitcoin.encode(i, buffer2, currentLen);
          }
          function writeVarSlice(slice) {
            writeVarInt(slice.length);
            writeSlice(slice);
          }
          function writeVector(vector) {
            writeVarInt(vector.length);
            vector.forEach(writeVarSlice);
          }
          writeVector(witness);
          return buffer2;
        }
</script>
<script>
        function decideMessageTypeAndNextSteps( decrypted_message, sender ) {
                if ( decrypted_message.includes( '{' ) ) {
                        var json = JSON.parse( decrypted_message );
                        if ( json[ "msgtype" ] == "initiation" ) {
                                acceptOrRejectCoinflipOffer( decrypted_message, sender );
                        }
                        if ( json[ "msgtype" ] == "acceptance" ) {
                                acknowledgeOrIgnoreCoinflip( decrypted_message, sender );
                        }
                        if ( json[ "msgtype" ] == "ack" ) {
                                console.log( "Got an ack message. Here is the decrypted message followed by the sender's pubkey:" );
                                console.log( decrypted_message, sender );
                                decideWhetherToSendMoneyAsPlayer2( decrypted_message, sender );
                        }
                }
        }
        function get16BytePreimage() {
                var length = 32;
                var preimagestage1 = bitcoinjs.ECPair.makeRandom().__D.toString( "hex" );
                var preimagestage2 = preimagestage1.substring( 0, length );
                return preimagestage2;
        }
        function get17BytePreimage() {
                var length = 34;
                var preimagestage1 = bitcoinjs.ECPair.makeRandom().__D.toString( "hex" );
                var preimagestage2 = preimagestage1.substring( 0, length );
                return preimagestage2;
        }
        function getRandom16or17BytePreimage() {
                var length = 16 + Math.floor( Math.random() * 2 );
                if ( length == 16 ) {
                        length = 32;
                } else {
                        length = 34;
                }
                var preimagestage1 = bitcoinjs.ECPair.makeRandom().__D.toString( "hex" );
                var preimagestage2 = preimagestage1.substring( 0, length );
                return preimagestage2;
        }
        async function sweepMoneyFromRevelationAddressAsPlayer2( realjson ) {
                //player 2 runs this
                var revelation_txid = await addyLooper( realjson[ "revelation-address" ], "player2", "sweepFromRevelationAddress" );
                sessionStorage[ revelation_txid ] = "0";
                var blocks_to_wait_for_revelation_address = Number( realjson[ "blocks_to_wait_for_revelation_address" ] );
                var blocks_to_wait_for_revelation_address_as_player_2 = 1;
                //abort if the amount in the revelation address is lower than the agreed upon amount
                var amount_in_revelation_address = await getAmountOfTxThatSentMeMoney( realjson[ "revelation-address" ], revelation_txid );
                if ( Number( amount_in_revelation_address ) < Number( realjson[ "amount" ] ) ) {
                        document.getElementById( "status-updates" ).prepend( document.getElementById( "aborted-due-to-wrong-amount-opponents-fault" ) );
                        document.getElementById( "status-updates" ).prepend( document.getElementById( "finished-status" ) );
                } else {
                        confLooper( revelation_txid, blocks_to_wait_for_revelation_address_as_player_2 );
                        await waitForTheRightNumberOfConfs( revelation_txid, blocks_to_wait_for_revelation_address_as_player_2, "player2", realjson[ "revelation-address" ] );
                        var revelation_txindex = await getOutputNumberOfTxThatSentMeMoney( realjson[ "revelation-address" ], revelation_txid );
                        var original_quantity_of_sats_in_revelation_address = ( Number( realjson[ "amount" ] ) );
                        var new_quantity_of_sats_for_revealing_preimage = original_quantity_of_sats_in_revelation_address - 250;
                        var player2PrivkeyForRevelationAddress = realjson[ "player2PrivkeyForRevelationAddress" ];
                        var player2PubkeyForRevelationAddress = realjson[ "player2PubkeyForRevelationAddress" ];
                        var player1PubkeyForRevelationAddress = realjson[ "player1PubkeyForRevelationAddress" ];
                        var player2Preimage = realjson[ "player2Preimage" ];
                        var hash = realjson[ "player2Hash" ];
                        var useraddress_for_revelation_address = "tb1ql7w62elx9ucw4pj5lgw4l028hmuw80sndtntxt";
                        revealPreimage( player2Preimage, player1PubkeyForRevelationAddress, player2PrivkeyForRevelationAddress, blocks_to_wait_for_revelation_address, revelation_txid, revelation_txindex, original_quantity_of_sats_in_revelation_address, new_quantity_of_sats_for_revealing_preimage, useraddress_for_revelation_address );
                        console.log( "Almost done! You withdrew from the revelation address." );
                }
        }
        async function sweepMoneyFromRevelationAddressAsPlayer1( realjson ) {
                //player 1 runs this
                var revelation_txid = await addyLooper( realjson[ "revelation-address" ], "player1", "sweepFromRevelationAddress" );
                document.getElementById( "status-updates" ).prepend( document.getElementById( "your-deposit-detected" ) );
                document.getElementById( "status-updates" ).prepend( document.getElementById( "awaiting-opponents-guess-status" ) );
                sessionStorage[ revelation_txid ] = "0";
                var blocks_to_wait_for_revelation_address = Number( realjson[ "blocks_to_wait_for_revelation_address" ] );
                confLooper( revelation_txid, blocks_to_wait_for_revelation_address );
                await waitForTheRightNumberOfConfs( revelation_txid, blocks_to_wait_for_revelation_address, "player2", realjson[ "revelation-address" ] );
                var revelation_txindex = await getOutputNumberOfTxThatSentMeMoney( realjson[ "revelation-address" ], revelation_txid );
                var original_quantity_of_sats_in_revelation_address = ( Number( realjson[ "amount" ] ) );
                var new_quantity_of_sats_for_withdrawing_after_timelock = original_quantity_of_sats_in_revelation_address - 250;
                var player1PrivkeyForRevelationAddress = realjson[ "player1PrivkeyForRevelationAddress" ];
                var player1PubkeyForRevelationAddress = realjson[ "player1PubkeyForRevelationAddress" ];
                var player2PubkeyForRevelationAddress = realjson[ "player2PubkeyForRevelationAddress" ];
                var hash = realjson[ "player2Hash" ];
                var useraddress_for_revelation_address = document.getElementById( "address" ).value;
                withdrawFromRevelationAddressAfterTimelockAsPlayer1( revelation_txid, revelation_txindex, original_quantity_of_sats_in_revelation_address, new_quantity_of_sats_for_withdrawing_after_timelock, player1PrivkeyForRevelationAddress, player2PubkeyForRevelationAddress, Number( realjson[ "blocks_to_wait_for_revelation_address" ] ), hash, useraddress_for_revelation_address );
                document.getElementById( "status-updates" ).prepend( "$ Aborted because your opponent took too long" + " (error code 01)" );
//                document.getElementById( "status-updates" ).prepend( document.getElementById( "aborted-due-to-timeout-opponents-fault" ) );
                document.getElementById( "status-updates" ).prepend( document.getElementById( "finished-status" ) );
        }
        async function sweepMoneyFromCoinflipAddressAsPlayer2( realjson ) {
                //player 2 runs this
                var coinflip_txid = await addyLooper( realjson[ "coinflip-address" ], "player2", "sweepFromCoinflipAddress" );
                sessionStorage[ coinflip_txid ] = "0";
                confLooper( coinflip_txid, Number( realjson[ "blocks_to_wait" ] ) );
                var didILose = await waitForTheRightNumberOfConfs( coinflip_txid, Number( realjson[ "blocks_to_wait" ] ), "player2", realjson[ "coinflip-address" ] );
                //Stop running "waitfortherightnumberofconfs" if I see that the other party withdrew the money, i.e. if the address has a spent txo, and alert the player that they lost.
                if ( didILose == "You lost :(" ) {
                        alert( "Oh no! You lost :(" );
                } else {
                        var txindex = await getOutputNumberOfTxThatSentMeMoney( realjson[ "coinflip-address" ], coinflip_txid );
                        var original_quantity_of_sats = ( Number( realjson[ "amount" ] ) * 2 );
                        var new_quantity_of_sats = original_quantity_of_sats - 250;
                        var player2Privkey = realjson[ "player2Privkey" ];
                        var player2Pubkey = realjson[ "player2Pubkey" ];
                        var player1Pubkey = realjson[ "player1Pubkey" ];
                        var player2Hash = realjson[ "player2Hash" ];
                        var player1Hash = realjson[ "player1Hash" ];
                        var randomPreimage1 = getRandom16or17BytePreimage();
                        var randomPreimage2 = getRandom16or17BytePreimage();
                        var blocks_to_wait = realjson[ "blocks_to_wait" ];
                        var useraddress = "tb1ql7w62elx9ucw4pj5lgw4l028hmuw80sndtntxt";
                        player2WonCoinflip( coinflip_txid, txindex, original_quantity_of_sats, new_quantity_of_sats, player2Privkey, player2Pubkey, player1Pubkey, randomPreimage1, randomPreimage2, blocks_to_wait, useraddress, player1Hash, player2Hash );
                        console.log( "Done! You won the bet!" );
                }
        }
        async function decideWhetherToSendMoneyAsPlayer2( decrypted_message, player1 ) {
                //player 2 runs this
                var json = JSON.parse( decrypted_message );
                var realjson = JSON.parse( localStorage[ "coinflip-private-info" ] );
                console.log( "here are the contents of coinflip-private-info at the point when I am trying to write a script to sweep the revelation address:", realjson );
                if ( json[ "player2Hash" ] == realjson[ "player2Hash" ] ) {
                        console.log( "Send", ( Number( realjson[ "amount" ] ) * 2 ), "sats to this address:" );
                        console.log( realjson[ "coinflip-address" ] );
                        //run a sweep function that takes money out of the revelation address after however many confs you agreed on for the revelation address
                        sweepMoneyFromRevelationAddressAsPlayer2( realjson );
                        //run a sweep function that takes money out of the coinflup address after however many confs you agreed on for the coinflip address
                        sweepMoneyFromCoinflipAddressAsPlayer2( realjson );
                }
        }
        async function acknowledgeOrIgnoreCoinflip( decrypted_message, player2 ) {
                //player 1 runs this
                var json = JSON.parse( decrypted_message );
                var claimedPlayer1Hash = json[ "player1Hash" ];
                var claimedRevelationAddress = json[ "revelation-address" ];
                var realjson = JSON.parse( localStorage[ "coinflip-private-info" ] );
                var realPlayer1Hash = realjson[ "player1Hash" ];
                if ( claimedPlayer1Hash == realPlayer1Hash ) {
                        var player2Hash = json[ "player2Hash" ];
                        var player2Pubkey = json[ "player2Pubkey" ];
                        var player1Hash = realPlayer1Hash;
                        var player1Pubkey = realjson[ "player1Pubkey" ];
                        var player1PubkeyForRevelationAddress = realjson[ "player1PubkeyForRevelationAddress" ];
                        var player2PubkeyForRevelationAddress = json[ "player2PubkeyForRevelationAddress" ];
                        var blocks_to_wait = Number( realjson[ "blocks_to_wait" ] );
                        var blocks_to_wait_for_revelation_address = Number( realjson[ "blocks_to_wait_for_revelation_address" ] );
                        var witnessscript = prepCoinflip( player1Hash, player2Hash, player1Pubkey, player2Pubkey, blocks_to_wait );
                        console.log( "witness script:", witnessscript );
                        var p2wsh = bitcoinjs.payments.p2wsh({redeem: {output: witnessscript, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
                        var witness_script_for_revelation_address = reveal_and_redeem( player2Hash, player1PubkeyForRevelationAddress, player2PubkeyForRevelationAddress, Number( blocks_to_wait_for_revelation_address ) );
                        console.log( "witness script for revelation address:", witness_script_for_revelation_address );
                        var p2wsh_for_revelation_address = bitcoinjs.payments.p2wsh({redeem: {output: witness_script_for_revelation_address, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
                        var revelation_address = p2wsh_for_revelation_address.address;
                        if ( p2wsh.address == json[ "coinflip-address" ] && revelation_address == claimedRevelationAddress && sessionStorage[ "status" ] != "accept-no-more-takers" ) {
                                //update the status indicator
                                sessionStorage[ "status" ] = "accept-no-more-takers";
                                document.getElementById( "status-updates" ).prepend( document.getElementById( "awaiting-ack-status" ) );
                                //update the private info
                                var coinflip_private_info = JSON.parse( localStorage[ "coinflip-private-info" ] );
                                coinflip_private_info[ "coinflip-address" ] = p2wsh.address;
                                coinflip_private_info[ "revelation-address" ] = revelation_address;
                                coinflip_private_info[ "player1Ack" ] = "ack";
                                coinflip_private_info[ "player2Hash" ] = player2Hash;
                                coinflip_private_info[ "player2Pubkey" ] = player2Pubkey;
                                coinflip_private_info[ "player2PubkeyForRevelationAddress" ] = player2PubkeyForRevelationAddress;
                                localStorage[ "coinflip-private-info" ] = JSON.stringify( coinflip_private_info );
                                //send an ack
                                var message = {}
                                message[ "msgtype" ] = "ack";
                                message[ "player1Hash" ] = player1Hash;
                                message[ "player2Hash" ] = player2Hash;
                                message = JSON.stringify( message );
                                makePrivateNote( message, player2 );
                                //update the status indicator
                                document.getElementById( "status-updates" ).prepend( document.getElementById( "awaiting-ack-status" ) );
                                document.getElementById( "status-updates" ).prepend( document.getElementById( "awaiting-opponents-deposit-status" ) );
                                //listen for a transaction into the coinflip address and if it arrives with an amount 2x the bet amount, await 1 confirmation
                                var coinflip_txid = await addyLooper( p2wsh.address, "player1", "depositIntoRevelationAddress" );
                                document.getElementById( "status-updates" ).prepend( document.getElementById( "opponents-deposit-detected" ) );
                                //Player 1 aborts (by not depositing money into the revelation address) if the coinflip address does not have money in it within 3 blocks after the game starts. The logic for this is in addyLooper.
                                sessionStorage[ coinflip_txid ] = "0";
                                var actual_amount_in_coinflip_address = await getAmountOfTxThatSentMeMoney( p2wsh.address, coinflip_txid );
                                if ( Number( actual_amount_in_coinflip_address ) >= ( Number( realjson[ "amount" ] ) * 2 ) ) {
                                        confLooper( coinflip_txid, 1 );
                                        var confs = await waitForTheRightNumberOfConfs( coinflip_txid, 1, "player1", coinflip_private_info[ "coinflip-address" ] );
                                        document.getElementById( "status-updates" ).prepend( document.getElementById( "awaiting-your-deposit-status" ) );
                                        document.getElementById( "status-amount" ).innerText = ( Number( realjson[ "amount" ] ) ).toString();
                                        document.getElementById( "status-revelation-address" ).innerText = coinflip_private_info[ "revelation-address" ];
                                        document.getElementById( "status-updates" ).prepend( document.getElementById( "deposit-into-the-revelation-address-status" ) );
                                        console.log( "Send", ( Number( coinflip_private_info[ "amount" ] ) ), "sats to this address:" );
                                        //The following sweep function sweeps money out of the revelation address if necessary after awaiting however many confs were agreed upon for the revelation address.
                                        //Remember that the revelation address should expire 4 blocks before the coinflip address, but since I assume it is possible that the player 2 has two blocks that player 1 doesn't know about, I also must assume it is possible for the revelation address to expire only 2 blocks before the coinflip address. Still, that shouldn't change anything if it happens, player 1 should still just abort and withdraw their money at that point, which should be plenty of time before player 2 can do anything nefarious.
                                        //TODO_TEST: Test what happens if player 2 decides to make a race condition here by broadcasting their preimage-based withdrawal at the same time as player 1's timelock-based withdrawal. What ought to happen is that player 1 should still get player 2's preimage and use it to try to withdraw from the coinflip address if they won. Status: I tried to create a race condition after player 1 broadcasted a transaction withdrawing their money but I got an error that said my transaction needs at least one input. I kind of expected it to say you can't spend an input that's already spent, and I also wondered if it might say I need to bump the fee higher to do rbf (which I don't think was even enabled), but the error I got is a little different from both of those (though it is kind of similar to the first one). I decoded the transaction on blockcypher and it seemed to have an input to me. So I'm not sure what to think of that but now I want to test what happens if player 2 broadcasts first.
                                        sweepMoneyFromRevelationAddressAsPlayer1( coinflip_private_info );
                                        console.log( coinflip_private_info[ "revelation-address" ] );
                                        var player2Preimage = await preimageLooper( coinflip_private_info[ "revelation-address" ], coinflip_private_info[ "player2Hash" ] );
                                        document.getElementById( "status-updates" ).prepend( document.getElementById( "opponents-guess-detected" ) );
                                        var player2PreimageLength = player2Preimage.length / 2;
                                        var player1Preimage = coinflip_private_info[ "player1Preimage" ];
                                        var player1PreimageLength = player1Preimage.length / 2;
                                        document.getElementById( "status-updates" ).prepend( document.getElementById( "checking-who-won-status" ) );
                                        if ( player2PreimageLength != player1PreimageLength ) {
                                                var txid = coinflip_txid;
                                                var txindex = await getOutputNumberOfTxThatSentMeMoney( p2wsh.address, coinflip_txid );
                                                var original_quantity_of_sats = Number( actual_amount_in_coinflip_address );
                                                var new_quantity_of_sats = actual_amount_in_coinflip_address - 250;
                                                var player1Privkey = coinflip_private_info[ "player1Privkey" ];
                                                var player1Pubkey = coinflip_private_info[ "player1Pubkey" ];
                                                var player2Pubkey = coinflip_private_info[ "player2Pubkey" ];
                                                var useraddress = document.getElementById( "address" ).value;
                                                player1WonCoinflip( txid, txindex, original_quantity_of_sats, new_quantity_of_sats, player1Privkey, player1Pubkey, player2Pubkey, player1Preimage, player2Preimage, blocks_to_wait, useraddress );
                                                document.getElementById( "status-updates" ).prepend( document.getElementById( "yay-you-won" ) );
                                                document.getElementById( "status-updates" ).prepend( document.getElementById( "finished-status" ) );
                                                console.log( "Done! You won the bet!" );
                                        } else {
                                                document.getElementById( "status-updates" ).prepend( document.getElementById( "oh-no-you-lost" ) );
                                                document.getElementById( "status-updates" ).prepend( document.getElementById( "finished-status" ) );
                                                console.log( "I lost. :(" );
                                        }
                                }
                        }
                }
        }
        function acceptOrRejectCoinflipOffer( decrypted_message, player1 ) {
                //player 2 runs this
                var json = JSON.parse( decrypted_message );
                //TODO: ensure each player can modify what wait times they'll accept for the coinflip address and the revelation address
                var blocks_to_wait = Number( json[ "blocks_to_wait" ] );
                var blocks_to_wait_for_revelation_address = Number( json[ "blocks_to_wait_for_revelation_address" ] );
                var amount = Number( json[ "amount" ] );
                //Note: The minimum wait time for the coinflip address that player 1 will accept is 8 blocks, see the todo under the function "acceptOrRejectCoinflipOffer" for reasons why. Player 2 sets a maximum of 1 more than that so that he doesn't have to wait forever.
                var maximum_blocks_to_wait = 9;
                if ( blocks_to_wait > maximum_blocks_to_wait ) {
                        return;
                }
                //Note: 4 blocks is the minimum expiry player 2 should accept for the revelation address. As long as it is 4 or more, player 2 doesn't need to worry if player 1 deposits money into the revelation address even with only 2 or 1 blocks left before the coinflip address expires. The worst case scenario that I think is worth considering is that player 1 knows about 2 blocks that player 2 doesn't know about. That is in a category that I consider unlikely-yes-but-still-too-possible if blocks are clearing quickly that day. If therefore player 1 only had to wait 3 blocks before withdrawing their money from the revelation address, and if player 1 knew about 2 blocks that player 2 didn't know about, player 1 could profit if player 2 revealed their preimage because player 1 could try to sweep money out of the revelation address *and* get player 2's preimage. (This would be possible under a 3 block waiting period because, if player 1 knew about 2 blocks that player 2 didn't know about, and player 2 disclosed their preimage, then player 2's transaction sweeping funds from the revelation address and player 1's transaction sweeping money from the revelation address would both be valid as of the next block, creating a race condition -- except regardless of the outcome of the race condition, player 1 would know player 2's preimage.) That could cause player 2 to reveal their preimage without gaining anything, which isn't supposed to happen. So player 2 needs to make sure player 1 waits at least 4 blocks before withdrawing their money from the revelation address, because I consider it so-unlikely-as-to-be-basically-impossible that player 1 knows about 3 blocks that player 2 doesn't know about. Therefore as long as player 1 has to wait 4 blocks, if player 1 deposits money into the revelation address when there are only 2 blocks before the coinflip address expires, player 2 should be happy to reveal his preimage, because even if the other party knows about 2 blocks that he doesn't know about yet, that only means the coinflip address actually expired without player 2 knowing about it for a few seconds, and in that case, he can be sure he'll learn about it before player 1 can withdraw their money from the revelation address, which means that player 2 can try to withdraw from the coinflip address *right now,* and they can *definitely* withdraw from the revelation address (player 1 still has to wait at least 2 blocks, even if he knows about 2 that player 2 doesn't know about), so player 2 can definitely sweep money out of the revelation address *and* (maybe) out of the revelation address (that part would just be a race, if player 1 won).
                var acceptable_blocks_to_wait_for_revelation_address = 4;
                if ( blocks_to_wait_for_revelation_address < acceptable_blocks_to_wait_for_revelation_address ) {
                        return;
                }
                if ( amount < Number( sessionStorage[ "minimum" ] ) || amount > Number( sessionStorage[ "maximum" ] ) ) {
                        return;
                }
                console.log( json );
                var player1Hash = json[ "hash" ];
                var player1Pubkey = json[ "pubkey" ];
                var player1PubkeyForRevelationAddress = json[ "pubkeyForRevelationAddress" ];
                var player2Preimage = getRandom16or17BytePreimage();
                console.log( "this is player two's preimage:", player2Preimage );
                console.log( "this is its length:", player2Preimage.length / 2 );
                var player2Hash = bitcoinjs.crypto.hash160( buffer.Buffer.from( player2Preimage, "hex" ) ).toString( "hex" );
                var player2Keypair = bitcoinjs.ECPair.makeRandom();
                var player2Privkey = player2Keypair.__D.toString( "hex" );
                var player2Pubkey = player2Keypair.publicKey.toString( "hex" );
                var player2KeypairForRevelationAddress = bitcoinjs.ECPair.makeRandom();
                var player2PrivkeyForRevelationAddress = player2Keypair.__D.toString( "hex" );
                var player2PubkeyForRevelationAddress = player2Keypair.publicKey.toString( "hex" );
                var witnessscript = prepCoinflip( player1Hash, player2Hash, player1Pubkey, player2Pubkey, blocks_to_wait );
                console.log( "witness script:", witnessscript );
                var p2wsh = bitcoinjs.payments.p2wsh({redeem: {output: witnessscript, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
                console.log( p2wsh.address );
                var witness_script_for_revelation_address = reveal_and_redeem( player2Hash, player1PubkeyForRevelationAddress, player2PubkeyForRevelationAddress, Number( blocks_to_wait_for_revelation_address ) );
                console.log( "witness script for relelation address:", witness_script_for_revelation_address );
                var p2wsh_for_revelation_address = bitcoinjs.payments.p2wsh({redeem: {output: witness_script_for_revelation_address, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
                var revelation_address = p2wsh_for_revelation_address.address;
                var coinflipPrivateInfo = {}
                coinflipPrivateInfo[ "player1" ] = player1;
                coinflipPrivateInfo[ "blocks_to_wait" ] = blocks_to_wait;
                coinflipPrivateInfo[ "blocks_to_wait_for_revelation_address" ] = blocks_to_wait_for_revelation_address;
                coinflipPrivateInfo[ "amount" ] = amount;
                coinflipPrivateInfo[ "player1Hash" ] = player1Hash;
                coinflipPrivateInfo[ "player1Pubkey" ] = player1Pubkey;
                coinflipPrivateInfo[ "player1PubkeyForRevelationAddress" ] = player1PubkeyForRevelationAddress;
                coinflipPrivateInfo[ "player2Preimage" ] = player2Preimage;
                coinflipPrivateInfo[ "player2Hash" ] = player2Hash;
                coinflipPrivateInfo[ "player2Privkey" ] = player2Privkey;
                coinflipPrivateInfo[ "player2Pubkey" ] = player2Pubkey;
                coinflipPrivateInfo[ "player2PrivkeyForRevelationAddress" ] = player2PrivkeyForRevelationAddress;
                coinflipPrivateInfo[ "player2PubkeyForRevelationAddress" ] = player2PubkeyForRevelationAddress;
                coinflipPrivateInfo[ "coinflip-address" ] = p2wsh.address;
                coinflipPrivateInfo[ "player1Ack" ] = "";
                coinflipPrivateInfo[ "revelation-address" ] = revelation_address;
                localStorage[ "coinflip-private-info" ] = JSON.stringify( coinflipPrivateInfo );
                console.log( coinflipPrivateInfo );
                var message = {}
                message[ "msgtype" ] = "acceptance";
                message[ "player1Hash" ] = player1Hash;
                message[ "player2Hash" ] = player2Hash;
                message[ "player2Pubkey" ] = player2Pubkey;
                message[ "player2PubkeyForRevelationAddress" ] = player2PubkeyForRevelationAddress;
                message[ "coinflip-address" ] = p2wsh.address;
                message[ "revelation-address" ] = revelation_address;
                message = JSON.stringify( message );
                makePrivateNote( message, player1 );
        }
        function startACoinflip( player2, amount ) {
                //player 1 runs this
                var player1Preimage = getRandom16or17BytePreimage();
                console.log( "this is player one's preimage:", player1Preimage );
                console.log( "this is its length:", player1Preimage.length / 2 );
                var player1Hash = bitcoinjs.crypto.hash160( buffer.Buffer.from( player1Preimage, "hex" ) ).toString( "hex" );
                var player1Keypair = bitcoinjs.ECPair.makeRandom();
                var player1Privkey = player1Keypair.__D.toString( "hex" );
                var player1Pubkey = player1Keypair.publicKey.toString( "hex" );
                var player1KeypairForRevelationAddress = bitcoinjs.ECPair.makeRandom();
                var player1PrivkeyForRevelationAddress = player1KeypairForRevelationAddress.__D.toString( "hex" );
                var player1PubkeyForRevelationAddress = player1KeypairForRevelationAddress.publicKey.toString( "hex" );
                //Note: The minimum wait time for the revelation address that player 2 will accept is 4 blocks, see the todo under the function "acceptOrRejectCoinflipOffer" for reasons why. A consequence of this is that the minimum wait time for the coinflip address should be 8 blocks. That is for several reasons, one of which is, Player 1 doesn't know if player 2 has 2 blocks that player 1 doesn't know about. Therefore Player 1 should not deposit money into the revelation address if the coinflip address is within 6 blocks of expiring, because otherwise player 2 could delay revealing their preimage until the revelation address's 4 blocks expire, which would be after (or at the same time as) they can withdraw money from the coinflip address. That would allow them to get Alice's money even if Alice won the coinflip, without giving Alice any recourse. Which means the minimum number of confs that player 1 should accept for the coinflip address is 8 if the wait time for the revelation address is 4 blocks. (Generalizing, player 1 should have a rule that the minimum wait time for the coinflip address be 4 more than the wait time for the revelation address, that way there is a next-to-impossible chance that player 2 can withdraw their money before player 1 can determine if they won the game. Also notable is that if the wait time for the coinflip address was only 3 more than the wait time for the revelation address, and if player 2 had 2 blocks that player 1 did not know about, player 2's withdrawal transaction would be valid at the same time as player 1's withdrawal transaction, creating a race condition. So player 1's minimum acceptable wait time for the coinflip address should be 4 more than the wait time of the revelation address.)
                var blocks_to_wait = "8";
                var blocks_to_wait_for_revelation_address = "4";
                //TODO: ensure each player can modify what wait times they'll accept for the coinflip address and the revelation address
                var message = {}
                message[ "msgtype" ] = "initiation";
                message[ "hash" ] = player1Hash;
                message[ "amount" ] = Number( amount );
                message[ "pubkey" ] = player1Pubkey;
                message[ "pubkeyForRevelationAddress" ] = player1PubkeyForRevelationAddress;
                message[ "blocks_to_wait" ] = blocks_to_wait;
                message[ "blocks_to_wait_for_revelation_address" ] = blocks_to_wait_for_revelation_address;
                message = JSON.stringify( message );
                var coinflipPrivateInfo = {}
                coinflipPrivateInfo[ "player2" ] = player2;
                coinflipPrivateInfo[ "blocks_to_wait" ] = blocks_to_wait;
                coinflipPrivateInfo[ "blocks_to_wait_for_revelation_address" ] = blocks_to_wait_for_revelation_address;
                coinflipPrivateInfo[ "amount" ] = Number( amount );
                coinflipPrivateInfo[ "player1Preimage" ] = player1Preimage;
                coinflipPrivateInfo[ "player1Hash" ] = player1Hash;
                coinflipPrivateInfo[ "player1Privkey" ] = player1Privkey;
                coinflipPrivateInfo[ "player1Pubkey" ] = player1Pubkey;
                coinflipPrivateInfo[ "player1PrivkeyForRevelationAddress" ] = player1PrivkeyForRevelationAddress;
                coinflipPrivateInfo[ "player1PubkeyForRevelationAddress" ] = player1PubkeyForRevelationAddress;
                coinflipPrivateInfo[ "player2Hash" ] = "";
                coinflipPrivateInfo[ "player2Pubkey" ] = "";
                coinflipPrivateInfo[ "player2PubkeyForRevelationAddress" ] = "";
                coinflipPrivateInfo[ "coinflip-address" ] = "";
                coinflipPrivateInfo[ "player1Ack" ] = "";
                coinflipPrivateInfo[ "revelation-address" ] = "";
                localStorage[ "coinflip-private-info" ] = JSON.stringify( coinflipPrivateInfo );
                console.log( coinflipPrivateInfo );
                makePrivateNote( message, player2 );
        }
        function createOffer( amount, preimage ) {
                //player 1 runs this
                var player1Preimage = preimage;
                console.log( "this is player one's preimage:", player1Preimage );
                console.log( "this is its length:", player1Preimage.length / 2 );
                var player1Hash = bitcoinjs.crypto.hash160( buffer.Buffer.from( player1Preimage, "hex" ) ).toString( "hex" );
                var player1Keypair = bitcoinjs.ECPair.makeRandom();
                var player1Privkey = player1Keypair.__D.toString( "hex" );
                var player1Pubkey = player1Keypair.publicKey.toString( "hex" );
                var player1KeypairForRevelationAddress = bitcoinjs.ECPair.makeRandom();
                var player1PrivkeyForRevelationAddress = player1KeypairForRevelationAddress.__D.toString( "hex" );
                var player1PubkeyForRevelationAddress = player1KeypairForRevelationAddress.publicKey.toString( "hex" );
                var blocks_to_wait = "8";
                var blocks_to_wait_for_revelation_address = "4";
                //TODO: ensure each player can modify what wait times they'll accept for the coinflip address and the revelation address
                var message = {}
                message[ "msgtype" ] = "offer";
                message[ "hash" ] = player1Hash;
                message[ "amount" ] = Number( amount );
                message[ "pubkey" ] = player1Pubkey;
                message[ "pubkeyForRevelationAddress" ] = player1PubkeyForRevelationAddress;
                message[ "blocks_to_wait" ] = blocks_to_wait;
                message[ "blocks_to_wait_for_revelation_address" ] = blocks_to_wait_for_revelation_address;
                message[ "offer_expires" ] = Math.floor( Date.now() / 1000 ) + 600;
                message = JSON.stringify( message );
                var coinflipPrivateInfo = {}
                coinflipPrivateInfo[ "player2" ] = "";
                coinflipPrivateInfo[ "blocks_to_wait" ] = blocks_to_wait;
                coinflipPrivateInfo[ "blocks_to_wait_for_revelation_address" ] = blocks_to_wait_for_revelation_address;
                coinflipPrivateInfo[ "amount" ] = Number( amount );
                coinflipPrivateInfo[ "player1Preimage" ] = player1Preimage;
                coinflipPrivateInfo[ "player1Hash" ] = player1Hash;
                coinflipPrivateInfo[ "player1Privkey" ] = player1Privkey;
                coinflipPrivateInfo[ "player1Pubkey" ] = player1Pubkey;
                coinflipPrivateInfo[ "player1PrivkeyForRevelationAddress" ] = player1PrivkeyForRevelationAddress;
                coinflipPrivateInfo[ "player1PubkeyForRevelationAddress" ] = player1PubkeyForRevelationAddress;
                coinflipPrivateInfo[ "player2Hash" ] = "";
                coinflipPrivateInfo[ "player2Pubkey" ] = "";
                coinflipPrivateInfo[ "player2PubkeyForRevelationAddress" ] = "";
                coinflipPrivateInfo[ "coinflip-address" ] = "";
                coinflipPrivateInfo[ "player1Ack" ] = "";
                coinflipPrivateInfo[ "revelation-address" ] = "";
                localStorage[ "coinflip-private-info" ] = JSON.stringify( coinflipPrivateInfo );
                console.log( coinflipPrivateInfo );
                putOfferOnNostr( message );
        }
</script>
<script>
        async function waitForTheRightNumberOfConfs( txid, num, player, address ) {
                if ( player == "player2" ) {
                        var tx_id = await addressOnceSentMoney( address );
                        if ( tx_id ) { 
                                return "You lost :(";
                        }
                }
                console.log( "loading confs for txid", txid + "..."  );
                num = Number( num );
                return new Promise( function( resolve, reject ) {
                        var confs = Number( sessionStorage[ txid ] );
                        console.log( "how many confs the txid has:", confs );
                        console.log( "how many confs it needs:", num );
                        console.log( "the first number is smaller than the second number:", confs < num );
                        if ( confs < num ) {
                                console.log( "since the first number was smaller than the second number I will rerun the function that waits for the right number of confs" );
                                setTimeout( async function() {
                                        var confs = await waitForTheRightNumberOfConfs( txid, num, player, address );
                                        resolve( confs );
                                }, 5000 );
                        } else {
                                resolve( confs );
                        }
                });
        }
        async function addyLooper( address, player, stage ) {
                if ( player == "player1" && stage == "depositIntoRevelationAddress" ) {
                        var current_blockheight = await getBlockheight();
                        console.log( "current_blockheight:", current_blockheight );
                        if ( !sessionStorage[ "block_when_game_started" ] || sessionStorage[ "block_when_game_started" ] == "" ) {
                                var block_when_game_started = current_blockheight;
                                sessionStorage[ "block_when_game_started" ] = block_when_game_started;
                        }
                        console.log( "block_when_game_started:", Number( sessionStorage[ "block_when_game_started" ] ) );
                        if ( Number( current_blockheight ) >= Number( sessionStorage[ "block_when_game_started" ] ) + 3 ) {
                                sessionStorage[ "status" ] = "aborted";
                                document.getElementById( "status-updates" ).prepend( "$ Aborted because your opponent took too long" + " (error code 02)" );

//                                document.getElementById( "status-updates" ).prepend( document.getElementById( "aborted-due-to-timeout-opponents-fault" ) + " (error code 02)" );
                                document.getElementById( "status-updates" ).prepend( document.getElementById( "finished-status" ) );
                        }
                }
                console.log( "loading txid for address", address + "..." );
                return new Promise( async function( resolve, reject ) {
                        var txid = await getIdOfTxThatSentMeMoney( address );
                        if ( txid == "none" ) {
                                if ( sessionStorage[ "status" ] == "aborted" ) {
                                        resolve( "none" );
                                } else {
                                        setTimeout( async function() {
                                                var txid = await addyLooper( address, player, stage );
                                                resolve( txid );
                                        }, 5000 );
                                }
                        } else {
                                resolve( txid );
                        }
                });
        }
        async function addyOutLooper( address ) {
                console.log( "loading spending txid for address", address + "..." );
                return new Promise( async function( resolve, reject ) {
                        var txid = await addressOnceSentMoney( address );
                        if ( !txid ) {
                                setTimeout( async function() {
                                        var txid = await addyOutLooper( address );
                                        resolve( txid );
                                }, 5000 );
                        } else {
                                resolve( txid );
                        }
                });
        }
        async function confLooper( txid, blocks_to_wait ) {
                blocks_to_wait = Number( blocks_to_wait );
                var confs = await howManyConfs( txid );
                confs = Number( confs );
                console.log( "waiting for confs involving this tx:", txid, "(I have to wait", blocks_to_wait, "blocks)" );
                sessionStorage[ txid ] = confs;
                if ( confs < blocks_to_wait ) {
                        setTimeout( function() {confLooper( txid, blocks_to_wait );}, 5000 );
                }
        }
        async function preimageLooper( address, hash ) {
                return new Promise( async function( resolve, reject ) {
                        var preimage = await getSweepablePreimageFromAllPossibilities( address, hash );
                        if ( !preimage || preimage == "" ) {
                                setTimeout( async function() {
                                        console.log( "loading preimage for hash", hash + "..." );
                                        var preimage = await preimageLooper( address, hash );
                                        resolve( preimage );
                                }, 15000 );
                        } else {
                                resolve( preimage );
                        }
                });
        }
        async function howManyConfs( txid ) {
            var blockheight = await getBlockheight();
            return new Promise( function( resolve, reject ) {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                    if ( this.readyState == 4 && this.status == 200 ) {
                        var json = JSON.parse( xhttp.responseText );
                        if ( json[ "status" ][ "confirmed" ] ) {
                            resolve( ( Number( blockheight ) - Number( json[ "status" ][ "block_height" ] ) ) + 1 );
                        } else {
                            resolve( "0".toString() );
                        }
                    }
                };
                xhttp.open( "GET", "https://blockstream.info/testnet/api/tx/" + txid, true );
                xhttp.send();
            });
        }
        async function getIdOfTxThatSentMeMoney( address ) {
            return new Promise( function( resolve, reject ) {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                    if ( this.readyState == 4 && this.status == 200 ) {
                        var json = JSON.parse( xhttp.responseText );
                        json.reverse();
                        var counter = 0;
                        json.forEach( function( tx ) {
                            tx[ "vout" ].forEach( function( vout ) {
                                if ( counter == 0 ) {
                                    if ( "scriptpubkey_address" in vout && vout[ "scriptpubkey_address" ] == address ) {
                                          resolve( tx[ "txid" ] );
                                          counter = counter + 1;
                                    }
                                }
                            });
                        });
                        resolve( "none" );
                    }
                };
                xhttp.open( "GET", "https://blockstream.info/testnet/api/address/" + address + "/txs", true );
                xhttp.send();
            });
        }
        function getOutputNumberOfTxThatSentMeMoney( address, txid ) {
            return new Promise( function( resolve, reject ) {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                    if ( this.readyState == 4 && this.status == 200 ) {
                        var json = JSON.parse( xhttp.responseText );
                        json.reverse();
                        var counter = 0;
                        json.forEach( function( tx ) {
                            tx[ "vout" ].forEach( function( vout, index ) {
                                if ( counter == 0 ) {
                                    if ( "scriptpubkey_address" in vout && vout[ "scriptpubkey_address" ] == address ) {
                                          resolve( index );
                                          counter = counter + 1;
                                    }
                                }
                            });
                        });
                    }
                };
                xhttp.open( "GET", "https://blockstream.info/testnet/api/address/" + address + "/txs", true );
                xhttp.send();
            });
        }
        function getAmountOfTxThatSentMeMoney( address, txid ) {
            return new Promise( function( resolve, reject ) {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                    if ( this.readyState == 4 && this.status == 200 ) {
                        var json = JSON.parse( xhttp.responseText );
                        json.reverse();
                        var counter = 0;
                        json.forEach( function( tx ) {
                            tx[ "vout" ].forEach( function( vout ) {
                                if ( counter == 0 ) {
                                    if ( "scriptpubkey_address" in vout && vout[ "scriptpubkey_address" ] == address ) {
                                          resolve( vout[ "value" ] );
                                          counter = counter + 1;
                                    }
                                }
                            });
                        });
                    }
                };
                xhttp.open( "GET", "https://blockstream.info/testnet/api/address/" + address + "/txs", true );
                xhttp.send();
            });
        }
</script>
<script>
        function prepCoinflip( player1Hash, player2Hash, player1Pubkey, player2Pubkey, blocks_to_wait ) {
            return bitcoinjs.script.fromASM(
                `
                    OP_TOALTSTACK
                    OP_DUP
                    OP_HASH160
                    ${ player1Hash }
                    OP_EQUAL
                    OP_NOTIF
                        OP_FALSE
                        OP_NIP
                    OP_ENDIF
                    OP_SIZE
                    ${ bitcoinjs.script.number.encode( 16 ).toString( 'hex' ) }
                    OP_EQUAL
                    OP_SWAP
                    OP_DROP
                    OP_FROMALTSTACK
                    OP_DUP
                    OP_HASH160
                    ${ player2Hash }
                    OP_EQUAL
                    OP_NOTIF
                        OP_FALSE
                        OP_NIP
                    OP_ENDIF
                    OP_SIZE
                    ${ bitcoinjs.script.number.encode( 16 ).toString( 'hex' ) }
                    OP_EQUAL
                    OP_SWAP
                    OP_DROP
                    OP_NUMNOTEQUAL
                    OP_IF
                        ${ player1Pubkey }
                    OP_ELSE
                        ${ bitcoinjs.script.number.encode( blocks_to_wait ).toString( 'hex' ) }
                        OP_CHECKSEQUENCEVERIFY
                        OP_DROP
                        ${ player2Pubkey }
                    OP_ENDIF
                    OP_CHECKSIG
                `
                .trim()
                .replace(/\s+/g, ' '),
            );
        }
        function reveal_and_redeem( player2Hash, player1Pubkey, player2Pubkey, blocks_to_wait ) {
            return bitcoinjs.script.fromASM(
                `
                    OP_SIZE
                    ${ bitcoinjs.script.number.encode( 16 ).toString( 'hex' ) }
                    ${ bitcoinjs.script.number.encode( 18 ).toString( 'hex' ) }
                    OP_WITHIN
                    OP_IF
                        OP_HASH160
                        ${ player2Hash }
                        OP_EQUALVERIFY
                        ${ player2Pubkey }
                    OP_ELSE
                       ${ bitcoinjs.script.number.encode( blocks_to_wait ).toString( 'hex' ) }
                       OP_CHECKSEQUENCEVERIFY
                       OP_DROP
                       ${ player1Pubkey }
                    OP_ENDIF
                    OP_CHECKSIG
                `
                .trim()
                .replace(/\s+/g, ' '),
            );
        }
        function player1WonCoinflip( txid, txindex, original_quantity_of_sats, new_quantity_of_sats, player1Privkey, player1Pubkey, player2Pubkey, player1Preimage, player2Preimage, blocks_to_wait, useraddress ) {
            var player1Hash = bitcoinjs.crypto.hash160( buffer.Buffer.from( player1Preimage, "hex" ) ).toString( 'hex' );
            var player2Hash = bitcoinjs.crypto.hash160( buffer.Buffer.from( player2Preimage, "hex" ) ).toString( 'hex' );
            var witnessscript = prepCoinflip( player1Hash, player2Hash, player1Pubkey, player2Pubkey, blocks_to_wait );
            console.log( "witness script:", witnessscript );
            var p2wsh = bitcoinjs.payments.p2wsh({redeem: {output: witnessscript, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
            console.log( p2wsh.address );
            var outputscript = "00" + bitcoinjs.crypto.sha256( witnessscript ).toString('hex');

            var psbt = new bitcoinjs.Psbt({network: bitcoinjs.networks.testnet});
            //psbt.setLocktime( timelock );
            psbt
              .addInput({
                hash: txid,
                index: txindex,
                sequence: 0xfffffffe,
                witnessUtxo: {
                          script: buffer.Buffer.from('0020' +
                                    bitcoinjs.crypto.sha256( buffer.Buffer.from( witnessscript, 'hex' ) ).toString( 'hex' ),
                                    'hex' ),
                          value: original_quantity_of_sats
                },
                witnessScript: buffer.Buffer.from( witnessscript, 'hex' )
              });
            psbt
                .addOutput({
                  address: useraddress,
                  value: new_quantity_of_sats,
                });
            psbt.signInput( 0, bitcoinjs.ECPair.fromPrivateKey( buffer.Buffer.from( player1Privkey, "hex" ) ) );

            var getFinalScripts = ( txindex, input, script) => {
              // Step 1: Check to make sure the meaningful locking script matches what you expect.
              var decompiled = bitcoinjs.script.decompile( script )
              if ( !decompiled || decompiled[0] !== bitcoinjs.opcodes.OP_TOALTSTACK ) {
                throw new Error( `Can not finalize input #${txindex}` )
              }

              // Step 2: Create final scripts
              var witnessStackPlayer1Branch = bitcoinjs.payments.p2wsh({
                  redeem: {
                      output: script,
                      input: bitcoinjs.script.compile([
                              input.partialSig[0].signature,
                              buffer.Buffer.from( player1Preimage, 'hex' ),
                              buffer.Buffer.from( player2Preimage, 'hex' ),
                      ]),
                  }
              });
              console.log('Player 1 branch witness stack:')
              console.log(witnessStackPlayer1Branch.witness.map(x => x.toString('hex')))
              return {
                  finalScriptWitness: witnessStackToScriptWitness( witnessStackPlayer1Branch.witness )
              }
            }
            psbt.finalizeInput( 0, getFinalScripts );
            setTimeout( function() {console.log( psbt.extractTransaction().toHex() );pushBTCpmt( psbt.extractTransaction().toHex() );}, 1000 );
        }
        function player2WonCoinflip( txid, txindex, original_quantity_of_sats, new_quantity_of_sats, player2Privkey, player2Pubkey, player1Pubkey, randomPreimage1, randomPreimage2, blocks_to_wait, useraddress, player1Hash, player2Hash ) {
                    var witnessscript = prepCoinflip( player1Hash, player2Hash, player1Pubkey, player2Pubkey, blocks_to_wait );
                    console.log( "witness script:", witnessscript );
                    var p2wsh = bitcoinjs.payments.p2wsh({redeem: {output: witnessscript, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
                    console.log( p2wsh.address );
                    var outputscript = "00" + bitcoinjs.crypto.sha256( witnessscript ).toString('hex');

                    var psbt = new bitcoinjs.Psbt({network: bitcoinjs.networks.testnet});
                    //psbt.setLocktime( timelock );
                    psbt
                      .addInput({
                        hash: txid,
                        index: txindex,
                        sequence: blocks_to_wait,
                        witnessUtxo: {
                                  script: buffer.Buffer.from('0020' +
                                            bitcoinjs.crypto.sha256( buffer.Buffer.from( witnessscript, 'hex' ) ).toString( 'hex' ),
                                            'hex'),
                                  value: original_quantity_of_sats
                        },
                        witnessScript: buffer.Buffer.from( witnessscript, 'hex' )
                      });
                    psbt
                        .addOutput({
                          address: useraddress,
                          value: new_quantity_of_sats,
                        });
                    psbt.signInput( 0, bitcoinjs.ECPair.fromPrivateKey( buffer.Buffer.from( player2Privkey, "hex" ) ) );

                    var getFinalScripts = ( txindex, input, script) => {
                      // Step 1: Check to make sure the meaningful locking script matches what you expect.
                      var decompiled = bitcoinjs.script.decompile( script )
                      if ( !decompiled || decompiled[0] !== bitcoinjs.opcodes.OP_TOALTSTACK ) {
                        throw new Error( `Can not finalize input #${txindex}` )
                      }

                      // Step 2: Create final scripts
                      var witnessStackPlayer2Branch = bitcoinjs.payments.p2wsh({
                          redeem: {
                              output: script,
                              input: bitcoinjs.script.compile([
                                      input.partialSig[0].signature,
                                      buffer.Buffer.from( randomPreimage1, 'hex' ),
                                      buffer.Buffer.from( randomPreimage2, 'hex' ),
                              ]),
                          }
                      });
                      console.log('Player 2 branch witness stack:')
                      console.log(witnessStackPlayer2Branch.witness.map(x => x.toString('hex')))
                      return {
                          finalScriptWitness: witnessStackToScriptWitness( witnessStackPlayer2Branch.witness )
                      }
                    }
                    psbt.finalizeInput( 0, getFinalScripts );
                    setTimeout( function() {console.log( psbt.extractTransaction().toHex() );pushBTCpmt( psbt.extractTransaction().toHex() );}, 1000 );
        }

        function withdrawFromRevelationAddressAfterTimelockAsPlayer1( txid, txindex, original_quantity_of_sats, new_quantity_of_sats, player1Privkey, player2Pubkey, blocks_to_wait, player2Hash, useraddress ) {
            blocks_to_wait = Number( blocks_to_wait );
            var player1Pubkey = nobleSecp256k1.getPublicKey( player1Privkey, true );
            var witnessscript = reveal_and_redeem( player2Hash, player1Pubkey, player2Pubkey, blocks_to_wait );
            console.log( "witness script:", witnessscript );
            var p2wsh = bitcoinjs.payments.p2wsh({redeem: {output: witnessscript, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
            console.log( p2wsh.address );
            var outputscript = "00" + bitcoinjs.crypto.sha256( witnessscript ).toString('hex');

            var psbt = new bitcoinjs.Psbt({network: bitcoinjs.networks.testnet});
            //psbt.setLocktime( timelock );
            psbt
              .addInput({
                hash: txid,
                index: txindex,
                sequence: blocks_to_wait,
                witnessUtxo: {
                          script: buffer.Buffer.from('0020' +
                                    bitcoinjs.crypto.sha256( buffer.Buffer.from( witnessscript, 'hex' ) ).toString( 'hex' ),
                                    'hex'),
                          value: original_quantity_of_sats
                },
                witnessScript: buffer.Buffer.from( witnessscript, 'hex' )
              });
            psbt
                .addOutput({
                  address: useraddress,
                  value: new_quantity_of_sats,
                });
            psbt.signInput( 0, bitcoinjs.ECPair.fromPrivateKey( buffer.Buffer.from( player1Privkey, "hex" ) ) );

            var getFinalScripts = ( txindex, input, script) => {
              // Step 1: Check to make sure the meaningful locking script matches what you expect.
              var decompiled = bitcoinjs.script.decompile( script )
              if ( !decompiled || decompiled[0] !== bitcoinjs.opcodes.OP_SIZE ) {
                throw new Error( `Can not finalize input #${txindex}` )
              }

              // Step 2: Create final scripts
              var witnessStackPlayer1Branch = bitcoinjs.payments.p2wsh({
                  redeem: {
                      output: script,
                      input: bitcoinjs.script.compile([
                              input.partialSig[0].signature,
                      ]),
                  }
              });
              console.log('Player 1 branch witness stack:')
              console.log(witnessStackPlayer1Branch.witness.map(x => x.toString('hex')))
              return {
                  finalScriptWitness: witnessStackToScriptWitness( witnessStackPlayer1Branch.witness )
              }
            }
            psbt.finalizeInput( 0, getFinalScripts );
            setTimeout( function() {console.log( psbt.extractTransaction().toHex() );pushBTCpmt( psbt.extractTransaction().toHex() );}, 1000 );
        }

        function revealPreimage( player2Preimage, player1Pubkey, player2Privkey, blocks_to_wait, txid, txindex, original_quantity_of_sats, new_quantity_of_sats, useraddress ) {
            var player2Pubkey = nobleSecp256k1.getPublicKey( player2Privkey, true );
            blocks_to_wait = Number( blocks_to_wait );
            var player2Hash = bitcoinjs.crypto.hash160( buffer.Buffer.from( player2Preimage, 'hex' ) ).toString( 'hex' );
            var witnessscript = reveal_and_redeem( player2Hash, player1Pubkey, player2Pubkey, blocks_to_wait );
            console.log( "witness script:", witnessscript );
            var p2wsh = bitcoinjs.payments.p2wsh({redeem: {output: witnessscript, network: bitcoinjs.networks.testnet}, network: bitcoinjs.networks.testnet });
            console.log( p2wsh.address );
            var outputscript = "00" + bitcoinjs.crypto.sha256( witnessscript ).toString('hex');

            var psbt = new bitcoinjs.Psbt({network: bitcoinjs.networks.testnet});
            //psbt.setLocktime( timelock );
            psbt
              .addInput({
                hash: txid,
                index: txindex,
                sequence: 0xfffffffe,
                witnessUtxo: {
                          script: buffer.Buffer.from('0020' +
                                    bitcoinjs.crypto.sha256( buffer.Buffer.from( witnessscript, 'hex' ) ).toString( 'hex' ),
                                    'hex'),
                          value: original_quantity_of_sats
                },
                witnessScript: buffer.Buffer.from( witnessscript, 'hex' )
              });
            psbt
                .addOutput({
                  address: useraddress,
                  value: new_quantity_of_sats,
                });
            psbt.signInput( 0, bitcoinjs.ECPair.fromPrivateKey( buffer.Buffer.from( player2Privkey, "hex" ) ) );

            var getFinalScripts = ( txindex, input, script) => {
              // Step 1: Check to make sure the meaningful locking script matches what you expect.
              var decompiled = bitcoinjs.script.decompile( script )
              if ( !decompiled || decompiled[0] !== bitcoinjs.opcodes.OP_SIZE ) {
                throw new Error( `Can not finalize input #${txindex}` )
              }

              // Step 2: Create final scripts
              var witnessStackPlayer2Branch = bitcoinjs.payments.p2wsh({
                  redeem: {
                      output: script,
                      input: bitcoinjs.script.compile([
                              input.partialSig[0].signature,
                              buffer.Buffer.from( player2Preimage, 'hex' ),
                      ]),
                  }
              });
              console.log('Player 2 branch witness stack:')
              console.log(witnessStackPlayer2Branch.witness.map(x => x.toString('hex')))
              return {
                  finalScriptWitness: witnessStackToScriptWitness( witnessStackPlayer2Branch.witness )
              }
            }
            psbt.finalizeInput( 0, getFinalScripts );
            setTimeout( function() {console.log( psbt.extractTransaction().toHex() );pushBTCpmt( psbt.extractTransaction().toHex() );}, 1000 );
        }

        function getPreimageFromTransactionThatSpendsAnHTLC( txid, pmthash ) {
                return new Promise( function( resolve, reject ) {
                        var xhttp = new XMLHttpRequest();
                        xhttp.onreadystatechange = function() {
                                if (this.readyState == 4 && this.status == 200) {
                                        var json = JSON.parse( xhttp.responseText );
                                        var i; for ( i=0; i<json[ "vin" ].length; i++ ) {
                                                var j; for ( j=0; j<json[ "vin" ][ i ][ "witness" ].length; j++ ) {
                                                        if ( bitcoinjs.crypto.hash160( buffer.Buffer.from( json[ "vin" ][ i ][ "witness" ][ j ], "hex" ) ).toString( "hex" ) == pmthash ) {
                                                                resolve( json[ "vin" ][ i ][ "witness" ][ j ] );
                                                        }
                                                }
                                        }
                                        resolve( "" );
                                }
                        };
                        xhttp.open("GET", "https://blockstream.info/testnet/api/tx/" + txid, true);
                        xhttp.send();
                });
        }
        function pushBTCpmt( rawtx ) {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                        if ( this.readyState == 4 && ( this.status == 200 || this.status == 201 ) ) {
                                var json = JSON.parse( this.responseText );
                                console.log( json );
                                console.log( "Your transaction was broadcasted, your txid is: " + json[ "tx" ][ "hash" ] );
                        }
                };
                xhttp.open( "POST", "https://api.blockcypher.com/v1/btc/test3/txs/push", true );
                xhttp.setRequestHeader( "Content-type", "text/plain" );
                xhttp.send( '{"tx":"' + rawtx + '"}' );
        }
        function getBlockheight() {
            return new Promise( function( resolve, reject ) {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                        if ( this.readyState == 4 && this.status == 200 ) {
                                var blockheight = Number( xhttp.responseText );
                                resolve( blockheight );
                        }
                };
                xhttp.open( "GET", "https://blockstream.info/testnet/api/blocks/tip/height", true );
                xhttp.send();
            });
        }
        function getBlockWhenTransactionWasMined( txid ) {
            return new Promise( function( resolve, reject ) {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                    if ( this.readyState == 4 && this.status == 200 ) {
                        var json = JSON.parse( xhttp.responseText );
                        if ( json[ "status" ][ "confirmed" ] ) {
                            resolve( Number( json[ "status" ][ "block_height" ] ) );
                        } else {
                            resolve( "0".toString() );
                        }
                    }
                };
                xhttp.open( "GET", "https://blockstream.info/testnet/api/tx/" + txid, true );
                xhttp.send();
            });
        }
        function getTransactionsInvolvingAddress( address ) {
                return new Promise( function( resolve, reject ) {
                        var xhttp = new XMLHttpRequest();
                        xhttp.onreadystatechange = function() {
                                if (this.readyState == 4 && this.status == 200) {
                                        var json = JSON.parse( xhttp.responseText );
                                        var txs = [];
                                        var i; for ( i=0; i<json.length; i++ ) {
                                                txs.push( json[ i ][ "txid" ] );
                                        }
                                        resolve( JSON.stringify( txs ) );
                                }
                        };
                        xhttp.open("GET", "https://blockstream.info/testnet/api/address/" + address + "/txs", true);
                        xhttp.send();
                });                
        }

        function waitSomeSeconds( num ) {
          var num = num.toString() + "000";
          num = Number( num );
          return new Promise( function( resolve, reject ) {
            setTimeout( function() { resolve( "I am waiting ten seconds because sometimes esplora updates intermittently where it knows a txid is associated with an address but does not have the info for that txid yet" ); }, num );
          });
        }

        function takeTxsAndGetPreimageFromThem( txs, hash ) {
            return new Promise( async function( resolve, reject ) {
                if ( txs.length > 1 ) {
                        console.log( "here comes the ten second timeout" );
                        var timeout = await waitSomeSeconds( 10 );
                        console.log( "ok the ten second timeout is done, let's continue" );
                        txs.forEach( async function( tx ) {
                            console.log( tx );
                            var possible_preimage = await getPreimageFromTransactionThatSpendsAnHTLC( tx, hash );
                            console.log( "here is the possible preimage I got (remember that it might be blank):", possible_preimage );
                            console.log( "if it is blank I will ignore it" );
                            if ( possible_preimage ) {
                                if ( possible_preimage.length == 32 || possible_preimage.length == 34 ) {
                                    console.log( "it was the right size so I will now return it (by the way, this is it:", possible_preimage );
                                    resolve( possible_preimage );
                                }
                            }
                        });
                } else {
                        resolve( "" );
                }
            });
        }

        async function getSweepablePreimageFromAllPossibilities( address, hash ) {
            return new Promise( async function( resolve, reject ) {
                var txs = await getTransactionsInvolvingAddress( address );
                var txs = JSON.parse( txs );
                var preimage = "";
                console.log( "Ok I am trying to get the preimage for this hash:", hash );
                console.log( "here are the transactions I can search for it in (remember that it might be blank, in which case I will just rerun in a bit):" );
                preimage += await takeTxsAndGetPreimageFromThem( txs, hash )
                console.log( "the preimage I will return is", preimage );
                resolve( preimage );
            });
        }

        function addressOnceSentMoney( address ) {
            return new Promise( function( resolve, reject ) {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                    if ( this.readyState == 4 && this.status == 200 ) {
                        var json = JSON.parse( xhttp.responseText );
                        if ( json[ "chain_stats" ][ "spent_txo_count" ] > 0 || json[ "mempool_stats" ][ "spent_txo_count" ] > 0 ) {
                            resolve( true );
                        }
                        resolve( false );
                    }
                };
                xhttp.open( "GET", "https://blockstream.info/testnet/api/address/" + address, true );
                xhttp.send();
            });
        }
</script>
<script>
        function addressOnceHadMoney( address ) {
            return new Promise( function( resolve, reject ) {
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function() {
                    if ( this.readyState == 4 && this.status == 200 ) {
                        var json = JSON.parse( xhttp.responseText );
                        if ( json[ "chain_stats" ][ "funded_txo_count" ] > 0 ) {
                            resolve( true );
                        }
                        resolve( false );
                    }
                };
                xhttp.open( "GET", "https://blockstream.info/testnet/api/address/" + address, true );
                xhttp.send();
            });
        }
</script>
<script>
        function putOfferOnNostr( offer ) {
                console.log( "note: '" + offer + "'" );
                var now = Math.floor( ( new Date().getTime() ) / 1000 );
                console.log( now );
                var newevent = [
                        0,
                        pubKeyMinus2,
                        now,
                        40,
                        [],
                        offer
                ];
                var message = JSON.stringify( newevent );
                console.log( "message: '" + message + "'" );
                var msghash = bitcoinjs.crypto.sha256( message ).toString( 'hex' );
                console.log( "msghash: '" + msghash + "'" );
                nobleSecp256k1.schnorr.sign( msghash, privKey ).then( 
                        value => { 
                                sig = value;
                                console.log( "the sig is:", sig );
                                nobleSecp256k1.schnorr.verify( 
                                        sig,
                                        msghash,
                                        pubKeyMinus2
                                ).then(
                                        value => { 
                                                console.log( "this should say true if the signature is valid for the above pubkey over the message", value );
                                                if ( value ) {
                                                        var fullevent = {
                                                                "id": msghash,
                                                                "pubkey": pubKeyMinus2,
                                                                "created_at": now,
                                                                "kind": 40,
                                                                "tags": [],
                                                                "content": offer,
                                                                "sig": sig
                                                        }
                                                        var sendable = [ "EVENT", fullevent ];
                                                        sessionStorage.sendable = JSON.stringify( sendable );
                                                        console.log( "here is what you will send:", sendable );
                                                        socket.send( '["EVENT",' + JSON.stringify( JSON.parse( sessionStorage.sendable )[ 1 ] ) + ']' );
                                                        if ( window.location.href.includes( "/index.html" ) || window.location.href.includes( "/interface.html" ) ) {
                                                                var endtag = ( window.location.href.includes( "/index.html" ) ) ? "/index.html":"/interface.html";
                                                                document.getElementById( "status-link" ).innerText = window.location.href.substring( 0, window.location.href.indexOf( endtag ) ) + "/offer.html?id=" + msghash;
                                                        } else {
                                                                document.getElementById( "status-link" ).innerText = window.location.href + "/offer.html?id=" + msghash;
                                                        }
                                                }
                                        }
                               );
                        }
                );
        }
        function makeNote( note ) {
                console.log( "note: '" + note + "'" );
                var now = Math.floor( ( new Date().getTime() ) / 1000 );
                console.log( now );
                var newevent = [
                        0,
                        pubKeyMinus2,
                        now,
                        1,
                        [],
                        note
                ];
                var message = JSON.stringify( newevent );
                console.log( "message: '" + message + "'" );
                var msghash = bitcoinjs.crypto.sha256( message ).toString( 'hex' );
                console.log( "msghash: '" + msghash + "'" );
                nobleSecp256k1.schnorr.sign( msghash, privKey ).then( 
                        value => { 
                                sig = value;
                                console.log( "the sig is:", sig );
                                nobleSecp256k1.schnorr.verify( 
                                        sig,
                                        msghash,
                                        pubKeyMinus2
                                ).then(
                                        value => { 
                                                console.log( "this should say true if the signature is valid for the above pubkey over the message", value );
                                                if ( value ) {
                                                        var fullevent = {
                                                                "id": msghash,
                                                                "pubkey": pubKeyMinus2,
                                                                "created_at": now,
                                                                "kind": 1,
                                                                "tags": [],
                                                                "content": note,
                                                                "sig": sig
                                                        }
                                                        var sendable = [ "EVENT", fullevent ];
                                                        sessionStorage.sendable = JSON.stringify( sendable );
                                                        socket.send( '["EVENT",' + JSON.stringify( JSON.parse( sessionStorage.sendable )[ 1 ] ) + ']' );
                                                 }
                                        }
                               );
                        }
                );
        }
        function makePrivateNote( note, recipientpubkey ) {
                console.log( "note: '" + note + "'" );
                var now = Math.floor( ( new Date().getTime() ) / 1000 );
                console.log( now );
                var privatenote = encrypt( privKey, recipientpubkey, note );
                var newevent = [
                        0,
                        pubKeyMinus2,
                        now,
                        4,
                        [['p', recipientpubkey]],
                        privatenote
                ];
                var message = JSON.stringify( newevent );
                console.log( "message: '" + message + "'" );
                var msghash = bitcoinjs.crypto.sha256( message ).toString( 'hex' );
                console.log( "msghash: '" + msghash + "'" );
                nobleSecp256k1.schnorr.sign( msghash, privKey ).then(
                        value => {
                                sig = value;
                                console.log( "the sig is:", sig );
                                nobleSecp256k1.schnorr.verify(
                                        sig,
                                        msghash,
                                        pubKeyMinus2
                                ).then(
                                        value => {
                                                console.log( "this should say true if the signature is valid for the above pubkey over the message", value );
                                                if ( value ) {
                                                        var fullevent = {
                                                                "id": msghash,
                                                                "pubkey": pubKeyMinus2,
                                                                "created_at": now,
                                                                "kind": 4,
                                                                "tags": [['p', recipientpubkey]],
                                                                "content": privatenote,
                                                                "sig": sig
                                                        }
                                                        var sendable = [ "EVENT", fullevent ];
                                                        sessionStorage.sendable = JSON.stringify( sendable );
                                                        socket.send( '["EVENT",' + JSON.stringify( JSON.parse( sessionStorage.sendable )[ 1 ] ) + ']' );
                                                 }
                                        }
                               );
                        }
                );
        }
        function encrypt( privkey, pubkey, text ) {
          console.log( "recipient pubkey (because I keep getting an error that it is not real):", pubkey );
          var key = nobleSecp256k1.getSharedSecret( privkey, '02' + pubkey, true ).substring( 2 );

          var iv = window.crypto.getRandomValues( new Uint8Array(16) );
          var cipher = browserifyCipher.createCipheriv(
            'aes-256-cbc',
            buffer.Buffer.from( key, 'hex' ),
            iv
          );
          var encryptedMessage = cipher.update( text, "utf8", "base64" );
          emsg = encryptedMessage + cipher.final( "base64" );

          return emsg + "?iv=" + buffer.Buffer.from( iv.buffer ).toString( "base64");
        }

        function decrypt( privkey, pubkey, ciphertext ) {
          var [ emsg, iv ] = ciphertext.split( "?iv=" );
          var key = nobleSecp256k1.getSharedSecret( privkey, '02' + pubkey, true ).substring( 2 );

          var decipher = browserifyCipher.createDecipheriv(
            'aes-256-cbc',
            buffer.Buffer.from( key, "hex" ),
            buffer.Buffer.from( iv, "base64" )
          );
          var decryptedMessage = decipher.update( emsg, "base64" );
          dmsg = decryptedMessage + decipher.final( "utf8" );

          return dmsg;
        }
        sessionStorage[ "maximum" ] = 10000;
        sessionStorage[ "minimum" ] = 1000;
</script>
</body>
</html>
